var documenterSearchIndex = {"docs":
[{"location":"api/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"api/","page":"Index","title":"Index","text":"","category":"page"},{"location":"api/#SuiteSplines.@suitesplines_reexport-Tuple","page":"Index","title":"SuiteSplines.@suitesplines_reexport","text":"@suitesplines_reexport(pkgs...)\n\nConvenience macro to reexport submodules of SuiteSplines.\n\nIf no arguments are passed, it reexports all submodules in SuiteSplines.SUITESPLINES_PKGS.\nIf one or more Symbols are passed (e.g., UnivariateSplines), only those specific submodules are reexported.\n\nThis macro expands to a block of @reexport using SuiteSplines.PkgName statements.\n\n\n\n\n\n","category":"macro"},{"location":"api/#SuiteSplines.SUITESPLINES_PKGS","page":"Index","title":"SuiteSplines.SUITESPLINES_PKGS","text":"Vector of package names included in the SuiteSplines.jl bundle (without .jl).\n\n\n\n\n\n","category":"constant"},{"location":"api/#LinearAlgebra.nullspace-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Real","page":"Index","title":"LinearAlgebra.nullspace","text":"nullspace(A::AbstractMatrix{T<:Real})\n\nConstruct a left basis for the null space of matrix A.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.nullspace-Union{Tuple{SparseArrays.SparseVector{T}}, Tuple{T}} where T<:Real","page":"Index","title":"LinearAlgebra.nullspace","text":"nullspace(a::AbstractVector{T}) where {T<:Real}\n\nFind a sparse basis for the null space of a vector. The entries are computed such that null space operator is maximally sparse and column sum of absolute values equals 1.0 for improved conditioning.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.IgaBase.boundary-Tuple{Any, Int64, Int64}","page":"Index","title":"SuiteSplines.IgaBase.boundary","text":"boundary(s; direction=1, component=1)\n∂(s; direction=1, component=1)\n\nReturn boundary component in direction of the object s.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.IgaBase.custom_replace_ref_begin_end!-Tuple{Any}","page":"Index","title":"SuiteSplines.IgaBase.custom_replace_ref_begin_end!","text":"replace_ref_begin_end!(ex)\n\nRecursively replace occurrences of the symbols :begin and :end in a \"ref\" expression (i.e. A[...]) ex with the appropriate function calls (firstindex or lastindex). Replacement uses the closest enclosing ref, so     A[B[end]] should transform to     A[B[lastindex(B)]]\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.IgaBase.AbstractMapping","page":"Index","title":"SuiteSplines.IgaBase.AbstractMapping","text":"AbstractMapping{Dim,S1,S2}\n\nAbstract type representing a mapping with an Dim dimensional domain, taking values in an S1 x S2 codimensional space.\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.IgaBase.AbstractSpline","page":"Index","title":"SuiteSplines.IgaBase.AbstractSpline","text":"AbstractSpline{Dim} <: ScalarMapping{Dim}\n\nAbstract subtype of ScalarMapping that represents a AbstractSpline function.\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.IgaBase.Boundary","page":"Index","title":"SuiteSplines.IgaBase.Boundary","text":"Boundary{S<:AbstractMapping}\n\nIterator over the boundary components of a mapping of type S.\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.IgaBase.Degree","page":"Index","title":"SuiteSplines.IgaBase.Degree","text":"Degree\n\nPolynomial degree (typeallias of Integer).\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.IgaBase.Dimension","page":"Index","title":"SuiteSplines.IgaBase.Dimension","text":"Dimension\n\nDimension (typeallias of Integer).\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.IgaBase.Regularity","page":"Index","title":"SuiteSplines.IgaBase.Regularity","text":"Regularity\n\nRegularity of the B-spline basis (typeallias of Integer).\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.IgaBase.ScalarMapping","page":"Index","title":"SuiteSplines.IgaBase.ScalarMapping","text":"ScalarMapping{Dim} <: AbstractMapping{Dim,1,1}\n\nAbstract subtype of AbstractMapping` that represents scalar-valued mappings.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.insert!-Union{Tuple{T}, Tuple{SuiteSplines.SortedSequences.NonDecreasingVector{T}, Integer, T}} where T","page":"Index","title":"Base.insert!","text":"insert!(v, index, item)\n\nThe Base.Insert! function is extended to operate on NonDecreasingVector and IncreasingVector. An argument-error will be thrown if the item leads to an unsorted sequence.\n\nExamples:\n\njulia> v = NonDecreasingVector([1,2,3,4]);\n\njulia> insert!(v, 3, 2)\n5-element Vector{Int64}:\n 1\n 2\n 2\n 3\n 4\n\njulia> v = IncreasingVector([1,2,4,5]);\n\njulia> insert!(v, 3, 3)\n5-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.SortedSequences.construct_vector-Union{Tuple{T}, Tuple{AbstractVector{T}, Vector{Int64}}} where T","page":"Index","title":"SuiteSplines.SortedSequences.construct_vector","text":"construct_vector(u, m)\n\nConstruct a vector by repeating the elements in u m times.\n\nExamples:\n\njulia> u = [0.0,1.0,2.5,3.0]\n4-element Vector{Float64}:\n 0.0\n 1.0\n 2.5\n 3.0\n\njulia> m = [2,1,2,3]\n4-element Vector{Int64}:\n 2\n 1\n 2\n 3\n\njulia> construct_vector(u, m)\n8-element Vector{Float64}:\n 0.0\n 0.0\n 1.0\n 2.5\n 2.5\n 3.0\n 3.0\n 3.0\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.SortedSequences.deconstruct_vector-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"Index","title":"SuiteSplines.SortedSequences.deconstruct_vector","text":"deconstruct_vector(v)\n\nDecompose a sequence into a new sequence, a multiplicity vector, and vectors specifying indexing into the sequence.\n\nExamples:\n\njulia> v = [0.0,0.0,1.0,2.0,2.0,3.0,3.0,3.0];\n\njulia> u, m, ia, ic = deconstruct_vector(v)\n([0.0, 1.0, 2.0, 3.0], [2, 1, 2, 3], [1, 1, 2, 3, 3, 4, 4, 4], [2, 3, 5, 8])\n\njulia> construct_vector(u,m)==v\ntrue\n\njulia> u[ia]==v\ntrue\n\njulia> v[ic]==u\ntrue\n\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.SortedSequences.global_insert-Union{Tuple{T}, Tuple{SuiteSplines.SortedSequences.NonDecreasingVector{T}, Int64}} where T","page":"Index","title":"SuiteSplines.SortedSequences.global_insert","text":"global_insert(v, k)\n\nUniformly subdivide new values into an IncreasingVector or NonDecreasingVector.\n\nExamples:\n\njulia> v = IncreasingVector([0.0,1.0,2.0])\n3-element IncreasingVector{Float64}:\n 0.0\n 1.0\n 2.0\n\njulia> global_insert(v, 3)\n9-element IncreasingVector{Float64}:\n 0.0\n 0.25\n 0.5\n 0.75\n 1.0\n 1.25\n 1.5\n 1.75\n 2.0\n\nWhen applied to a NonDecreasingVector only the non-zero length intervals are subdivided\n\njulia> v = NonDecreasingVector([0.0,0.0,1.0,1.0,2.0])\n5-element NonDecreasingVector{Float64}:\n 0.0\n 0.0\n 1.0\n 1.0\n 2.0\n\njulia> global_insert(v, 3)\n11-element NonDecreasingVector{Float64}:\n 0.0\n 0.0\n 0.25\n 0.5\n 0.75\n 1.0\n 1.0\n 1.25\n 1.5\n 1.75\n 2.0\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.SortedSequences.IncreasingRange","page":"Index","title":"SuiteSplines.SortedSequences.IncreasingRange","text":"IncreasingRange{T<:Real}\n\nConstruct an increasing range of real numbers.\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.SortedSequences.IncreasingSequence","page":"Index","title":"SuiteSplines.SortedSequences.IncreasingSequence","text":"IncreasingSequence{T}\n\nAbstract type for increasing sequences of real numbers.\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.SortedSequences.IncreasingVector","page":"Index","title":"SuiteSplines.SortedSequences.IncreasingVector","text":"IncreasingVector{T<:Real}\n\nConstruct a vector with an increasing set of real numbers.\n\nExamples:\n\nThe element type T is a subtype of Real. Hence it is possible to make IncreasingVector{Int64} as well as IncreasingVector{Float64}\n\njulia> IncreasingVector([0,1,2,3])\n4-element IncreasingVector{Int64}:\n 0\n 1\n 2\n 3\n\njulia> IncreasingVector([0.0,1.0,2.0,3.0])\n4-element IncreasingVector{Float64}:\n 0.0\n 1.0\n 2.0\n 3.0\n\nIt is also possible to extract the unique values of a NonDecreasingVector into an IncreasingVector.\n\njulia> v = NonDecreasingVector([0.0,0.0,1.0,2.0,2.0,3.0,3.0])\n7-element NonDecreasingVector{Float64}:\n 0.0\n 0.0\n 1.0\n 2.0\n 2.0\n 3.0\n 3.0\n\njulia> IncreasingVector(v)\n4-element IncreasingVector{Float64}:\n 0.0\n 1.0\n 2.0\n 3.0\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.SortedSequences.Interval","page":"Index","title":"SuiteSplines.SortedSequences.Interval","text":"Interval(a::T, b::T)\n\nCreate an interval from a point a to a point b.\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.SortedSequences.NonDecreasingSequence","page":"Index","title":"SuiteSplines.SortedSequences.NonDecreasingSequence","text":"NonDecreasingSequence{T}\n\nAbstract type for non-decreasing sequences of real numbers.\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.SortedSequences.NonDecreasingVector","page":"Index","title":"SuiteSplines.SortedSequences.NonDecreasingVector","text":"NonDecreasingVector{T}\n\nConstruct a vector with a non-decreasing set of real numbers.\n\nExamples:\n\njulia> v = NonDecreasingVector([0.0,0.0,1.0,2.0,2.0])\n5-element NonDecreasingVector{Float64}:\n 0.0\n 0.0\n 1.0\n 2.0\n 2.0\n\njulia> u, m = deconstruct_vector(v)\n([0.0, 1.0, 2.0], [2, 1, 2], [1, 1, 2, 3, 3], [2, 3, 5])\n\njulia> u\n3-element IncreasingVector{Float64}:\n 0.0\n 1.0\n 2.0\n\njulia> NonDecreasingVector(u, m) == v\ntrue\n\nIt is also possible to extract the unique values of a NonDecreasingVector into an IncreasingVector.\n\njulia> v = NonDecreasingVector([0.0,0.0,1.0,2.0,2.0,3.0,3.0])\n7-element NonDecreasingVector{Float64}:\n 0.0\n 0.0\n 1.0\n 2.0\n 2.0\n 3.0\n 3.0\n\njulia> IncreasingVector(v)\n4-element IncreasingVector{Float64}:\n 0.0\n 1.0\n 2.0\n 3.0\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.SortedSequences.SortedSequence","page":"Index","title":"SuiteSplines.SortedSequences.SortedSequence","text":"SortedSequence{T}\n\nAbstract type for sorted sequences of real numbers.\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.SortedSequences.Unique","page":"Index","title":"SuiteSplines.SortedSequences.Unique","text":"Unique(v)\n\nConvenience iterator that lazily returns a tuple with the unique consecutive values and their multiplicities.\n\nExamples:\n\njulia> v = [1,1,3,4,5,5,5,6,6,7];\n\njulia> for item in Unique(v)\n           @show item\n       end\nitem = (1, 2)\nitem = (3, 1)\nitem = (4, 1)\nitem = (5, 3)\nitem = (6, 2)\nitem = (7, 1)\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.collect-Tuple{SuiteSplines.CartesianProducts.CartesianProduct}","page":"Index","title":"Base.collect","text":"collect(X)\n\nCollect values of CartesianProduct{T,Dim} in Dim-dimensional arrays. Similar to ndgrid in Matlab.\n\nExamples:\n\njulia> x, y = collect([1,2] ⨱ [2,3,4]);\n\njulia> x\n2×3 Matrix{Int64}:\n 1  1  1\n 2  2  2\n\njulia> y\n2×3 Matrix{Int64}:\n 2  3  4\n 2  3  4\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.adjoint-Tuple{SuiteSplines.KroneckerProducts.BoxProduct}","page":"Index","title":"Base.adjoint","text":"adjoint(K::BoxProduct)\n\nCompute the adjoint of a Box product.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.adjoint-Tuple{SuiteSplines.KroneckerProducts.KroneckerProduct}","page":"Index","title":"Base.adjoint","text":"adjoint(K::KroneckerProduct)\n\nCompute the adjoint of a Kronecker product.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.inv-Tuple{SuiteSplines.KroneckerProducts.BoxProduct}","page":"Index","title":"Base.inv","text":"inv(K::BoxProduct)\n\nCompute the inverse of a Box product.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.inv-Tuple{SuiteSplines.KroneckerProducts.KroneckerProduct}","page":"Index","title":"Base.inv","text":"inv(K::KroneckerProduct)\n\nCompute the inverse of a Kronecker product.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.kron-Tuple{AbstractArray}","page":"Index","title":"Base.kron","text":"collect(K::KroneckerProduct)\n\nCollects a lazy instance of the KroneckerProduct type into a full, native matrix. Equivalent with Matrix(K::KroneckerProduct).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.transpose-Tuple{SuiteSplines.KroneckerProducts.BoxProduct}","page":"Index","title":"Base.transpose","text":"transpose(K::BoxProduct)\n\nCompute the transpose of a Box product.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.transpose-Tuple{SuiteSplines.KroneckerProducts.KroneckerProduct}","page":"Index","title":"Base.transpose","text":"transpose(K::KroneckerProduct)\n\nCompute the transpose of a Kronecker product.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.det-Union{Tuple{SuiteSplines.KroneckerProducts.BoxProduct{M, T, 2}}, Tuple{T}, Tuple{M}} where {M, T}","page":"Index","title":"LinearAlgebra.det","text":"det(K::BoxProduct)\n\nCompute the determinant of a Box product.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.det-Union{Tuple{SuiteSplines.KroneckerProducts.KroneckerProduct{T, 2}}, Tuple{T}} where T","page":"Index","title":"LinearAlgebra.det","text":"det(K::KroneckerProduct)\n\nCompute the determinant of a Kronecker product.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.eigen-Tuple{SuiteSplines.KroneckerProducts.KroneckerProduct}","page":"Index","title":"LinearAlgebra.eigen","text":"eigen(K::KroneckerProduct)\n\nIf the matrices of a KroneckerProduct instance are square, performs the eigenvalue decompositon on them and return an Eigen type.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.isposdef-Tuple{SuiteSplines.KroneckerProducts.AbstractKron}","page":"Index","title":"LinearAlgebra.isposdef","text":"isposdef(K::KroneckerProduct)\n\nTest whether a Kronecker product is positive definite (and Hermitian) by trying to perform a Cholesky factorization of K.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.issymmetric-Tuple{SuiteSplines.KroneckerProducts.AbstractKron}","page":"Index","title":"LinearAlgebra.issymmetric","text":"issymmetric(K::KroneckerProduct)\n\nChecks if a Kronecker product is symmetric.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.lmul!-Tuple{Number, SuiteSplines.KroneckerProducts.AbstractKron}","page":"Index","title":"LinearAlgebra.lmul!","text":"lmul!(a::Number, K::KroneckerProduct)\n\nScale a KroneckerProduct K inplace by a factor a by rescaling the left matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.logdet-Union{Tuple{SuiteSplines.KroneckerProducts.KroneckerProduct{T, 2}}, Tuple{T}} where T","page":"Index","title":"LinearAlgebra.logdet","text":"logdet(K::KroneckerProduct)\n\nCompute the logarithm of the determinant of a Kronecker product.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.rmul!-Tuple{SuiteSplines.KroneckerProducts.AbstractKron, Number}","page":"Index","title":"LinearAlgebra.rmul!","text":"rmul!(K::KroneckerProduct, a::Number)\n\nScale a KroneckerProduct K inplace by a factor a by rescaling the right matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.tr-Union{Tuple{SuiteSplines.KroneckerProducts.KroneckerProduct{T, 2}}, Tuple{T}} where T","page":"Index","title":"LinearAlgebra.tr","text":"tr(K::KroneckerProduct)\n\nCompute the trace of a Kronecker product.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.IgaBase.order-Tuple{AbstractMatrix}","page":"Index","title":"SuiteSplines.IgaBase.order","text":"order(M::AbstractMatrix)\n\nReturns the order of a matrix, i.e. how many matrices are involved in the Kronecker product (default to 1 for general matrices).\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.KroneckerProducts.box","page":"Index","title":"SuiteSplines.KroneckerProducts.box","text":"box(A, B)\nbox(A, B...)\n\nCompute the box product, which is defined as a perfect shuffle of a kronecker product.\n\n\n\n\n\n","category":"function"},{"location":"api/#SuiteSplines.KroneckerProducts.issquare-Tuple{AbstractMatrix}","page":"Index","title":"SuiteSplines.KroneckerProducts.issquare","text":"issquare(A::AbstractMatrix)\n\nChecks if an array is a square matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.Matrix-Tuple{SuiteSplines.KroneckerProducts.AbstractKron}","page":"Index","title":"Base.Matrix","text":"Matrix(K::KroneckerProduct)\n\nConverts a GeneralizedKroneckerProduct instance to a Matrix type.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.KroneckerProducts.BoxProduct","page":"Index","title":"SuiteSplines.KroneckerProducts.BoxProduct","text":"BoxProduct{M,T,N} <: AbstractKron{M,T,N}\n\nThe box product is defined in the following paper.\n\nOlsen, Peder A., Steven J. Rennie, and Vaibhava Goel. \"Efficient automatic differentiation of matrix functions.\" In Recent Advances in Algorithmic Differentiation, pp. 71-81. Springer, Berlin, Heidelberg, 2012.\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.KroneckerProducts.KroneckerProduct","page":"Index","title":"SuiteSplines.KroneckerProducts.KroneckerProduct","text":"KroneckerProduct{T,N,S}  <: AbstractVecOrMat{T}\n\nMatrix type that stores the matrices in a Kronecker product and lazily evaluates products, sums, etc.\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.AbstractMappings.l2_error-Tuple{Any}","page":"Index","title":"SuiteSplines.AbstractMappings.l2_error","text":"l2_error(f; to, relative=false, quadrule=standard_quadrature_rule(f,g))\n\nCompute the (relative) L^2 error of f with respect to g. Any f and g will do as long as @cartesian and standard_quadrature_rule(f,g) are implemented.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.AbstractMappings.EvaluationSet","page":"Index","title":"SuiteSplines.AbstractMappings.EvaluationSet","text":"EvaluationSet{S1,S2, S}\n\nSet of evaluation points that are used as input and output of functions, mappings and fields.\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.AbstractMappings.ResizableArray","page":"Index","title":"SuiteSplines.AbstractMappings.ResizableArray","text":"ResizableArray{T,Dim} <: AbstractArray{T, Dim}\n\nArray-type that may be resized. New resources will be allocated if the new array-length exceeds maxlen. \n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.AbstractMappings.@evaluate!-Tuple{Any}","page":"Index","title":"SuiteSplines.AbstractMappings.@evaluate!","text":"@evaluate! Y = f(x)\n@evaluate! Y += f(x)\n@evaluate! Y -= f(x)\n@evaluate! Y *= f(x)\n@evaluate! Y /= f(x)\n\nFast update routine for evaluating a mapping on a grid  x . array Y needs to be preallocated.\n\n\n\n\n\n","category":"macro"},{"location":"api/#SuiteSplines.AbstractMappings.@evaluate-Tuple{Any}","page":"Index","title":"SuiteSplines.AbstractMappings.@evaluate","text":"@evaluate Y  = f(x)\n\nFast evaluation routine for evaluating a mapping on a grid  x . The result is stored in array Y. Allocation is done automatically and EvaluationSet's of the correct size and type are cached for each mapping using an LRUCache.\n\n\n\n\n\n","category":"macro"},{"location":"api/#SuiteSplines.BezierBernsteinMethods.Binomial-Union{Tuple{K}, Tuple{N}, Tuple{Val{N}, Val{K}}} where {N, K}","page":"Index","title":"SuiteSplines.BezierBernsteinMethods.Binomial","text":"Binomial(Val(n), Val(k)) = binomial(n,k)\n\n@generated function for optimized computation of binomials.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.BezierBernsteinMethods.b2c-Tuple{SuiteSplines.BezierBernsteinMethods.AbstractSimplex}","page":"Index","title":"SuiteSplines.BezierBernsteinMethods.b2c","text":"b2c(simplex)\n\nReturn the mapping (matrix) that maps barycentric coordinates to Cartesian coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.BezierBernsteinMethods.barycentriccoords-Tuple{SuiteSplines.BezierBernsteinMethods.AbstractSimplex, Any}","page":"Index","title":"SuiteSplines.BezierBernsteinMethods.barycentriccoords","text":"barycentriccoords(S::AbstractSimplex, x)\n\nCompute the barycentric coordinates of a point, or matrix of points x.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.BezierBernsteinMethods.bernstein-Union{Tuple{T}, Tuple{D}, Tuple{Integer, AbstractVector{T}, SuiteSplines.BezierBernsteinMethods.BPoint{D, T}}} where {D, T}","page":"Index","title":"SuiteSplines.BezierBernsteinMethods.bernstein","text":"bernstein(p::Degree, control::AbstractVector{T}, λ::BPoint{D,T})\n\nCompute Bezier polynomial at barycentric point λ with the degrees of freedom in control.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.BezierBernsteinMethods.bernsteinfuns-Union{Tuple{T}, Tuple{D}, Tuple{X}, Tuple{Val{X}, SuiteSplines.BezierBernsteinMethods.BPoint{D, T}}} where {X, D, T}","page":"Index","title":"SuiteSplines.BezierBernsteinMethods.bernsteinfuns","text":"bernstein(X::MultiIndex{D}, λ::BPoint{D,T})\n\nCompute single Bernstein basis function corresponding to multi-index X at barycentric point λ.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.BezierBernsteinMethods.cartesiancoords-Tuple{SuiteSplines.BezierBernsteinMethods.AbstractSimplex, Any}","page":"Index","title":"SuiteSplines.BezierBernsteinMethods.cartesiancoords","text":"cartesiancoords(S::AbstractSimplex, λ)\n\nCompute the Cartesian coordinates of a barycentric point or vector of barycentric points λ.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.BezierBernsteinMethods.decasteljau!-Union{Tuple{T}, Tuple{D}, Tuple{Integer, AbstractVector{T}, SuiteSplines.BezierBernsteinMethods.BPoint{D, T}}} where {D, T}","page":"Index","title":"SuiteSplines.BezierBernsteinMethods.decasteljau!","text":"decasteljau!(control::Vector{T}, λ::BPoint{D,T}, MultiIndices)\n\nClassic DeCasteljau algorithm (can compute derivatives too!) on a (D-1)-dimensional simplex.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.BezierBernsteinMethods.degree_elevation_operator","page":"Index","title":"SuiteSplines.BezierBernsteinMethods.degree_elevation_operator","text":"degree_elevation_operator(p::Degree, d::Dimension)\n\nReturn a matrix that maps degrees of freedom of a Bezier polynomial of degree p to the degrees of freedom corresponding to its order elevated Bezier polynomial.\n\n\n\n\n\n","category":"function"},{"location":"api/#SuiteSplines.BezierBernsteinMethods.grevillepoint-Tuple{NTuple{D, Integer} where D}","page":"Index","title":"SuiteSplines.BezierBernsteinMethods.grevillepoint","text":"grevillepoint(X::MultiIndex)\n\nCompute Greville point associated with multi-index label X.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.BezierBernsteinMethods.jacobian-Tuple{SuiteSplines.BezierBernsteinMethods.AbstractSimplex}","page":"Index","title":"SuiteSplines.BezierBernsteinMethods.jacobian","text":"jacobian(simplex)\n\nReturn the Jacobian mapping of a simplex.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.BezierBernsteinMethods.kformbasisconv-Tuple{Integer, Integer, Integer}","page":"Index","title":"SuiteSplines.BezierBernsteinMethods.kformbasisconv","text":"kformbasisconv(n::Dimension, k::Form, r::Degree)\n\nCompute the linear mapping from Bernstein polynomials to the space of k-forms Pᵣ⁻Λᵏ(T). This linear mapping is encoded in Pattern{T}. We refer to the paper. For more information, check out the periodic table of finite elements\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.BezierBernsteinMethods.linindex-Tuple{Integer, Integer}","page":"Index","title":"SuiteSplines.BezierBernsteinMethods.linindex","text":"linindex(i, j, k...)\n\nReturn the linear index of a multi-index label.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.BezierBernsteinMethods.mass_matrix-Union{Tuple{D}, Tuple{SuiteSplines.BezierBernsteinMethods.AbstractSimplex{D}, Integer, Integer}, Tuple{SuiteSplines.BezierBernsteinMethods.AbstractSimplex{D}, Integer, Integer, Type{<:Real}}} where D","page":"Index","title":"SuiteSplines.BezierBernsteinMethods.mass_matrix","text":"mass_matrix(S::AbstractSimplex{D}, p::Degree, q::Degree, T::Type{<:Real} = Type{Float64})\n\nCompute Bernstein mass matrix for degree (p,q) and dimension d.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.BezierBernsteinMethods.multiindex-Union{Tuple{SuiteSplines.BezierBernsteinMethods.LinearIndex{P, 2, I}}, Tuple{I}, Tuple{P}} where {P, I}","page":"Index","title":"SuiteSplines.BezierBernsteinMethods.multiindex","text":"MultiIndex(::LinearIndex{P<:Degree, D<:Dimension, I<:Integer})\n\nReturn the multi-index associated with linear index I and simplicial domain of degree P and dimension D.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.BezierBernsteinMethods.step_decasteljau!-Union{Tuple{T}, Tuple{D}, Tuple{Vector{T}, SuiteSplines.BezierBernsteinMethods.BPoint{D, T}, Any}} where {D, T}","page":"Index","title":"SuiteSplines.BezierBernsteinMethods.step_decasteljau!","text":"step_decasteljau!(control::Vector{T}, λ::BPoint{D,T}, MultiIndices)\n\nComputes a single step of the recursive DeCasteljau algorithm on a (D-1)-dimensional simplex.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.BezierBernsteinMethods.subsets-Union{Tuple{K}, Tuple{N}, Tuple{NTuple{N, Int64}, Val{K}}} where {N, K}","page":"Index","title":"SuiteSplines.BezierBernsteinMethods.subsets","text":"subsets(v::NTuple{n,Int}, k::Int)\n\nGenerate the binomial(n,k) unique subsets of length k from set v and its complement.\n\nExamples:\n\njulia> α, β = subsets((1,2,3), 1);\n\njulia> α\n3-element Array{Tuple{Int64},1}:\n (1,)\n (2,)\n (3,)\n\njulia> β\n3-element Array{Tuple{Int64,Int64},1}:\n (2, 3)\n (1, 3)\n (1, 2)\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.BezierBernsteinMethods.vol-Tuple{SuiteSplines.BezierBernsteinMethods.AbstractSimplex}","page":"Index","title":"SuiteSplines.BezierBernsteinMethods.vol","text":"vol(simplex)\n\nCompute the volume of an affine simplex.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.IgaBase.dimension-Union{Tuple{SuiteSplines.BezierBernsteinMethods.AbstractSimplex{D}}, Tuple{D}} where D","page":"Index","title":"SuiteSplines.IgaBase.dimension","text":"dimension(simplex)\n\nReturn the dimension of a simplex.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.IgaBase.dimsplinespace-Tuple{Integer, Integer}","page":"Index","title":"SuiteSplines.IgaBase.dimsplinespace","text":"dimsplinespace(p::Degree, d::Dimension)\n\nCompute the dimension of the Bezier spline space on a simplex of degree p and numer of vertices d.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.BezierBernsteinMethods.BezierSimplex","page":"Index","title":"SuiteSplines.BezierBernsteinMethods.BezierSimplex","text":" BezierSimplex{D,T<:Real} <: AbstractSimplex{D}\n\nSimplex of dimension D with Vertices in real number type T.\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.BezierBernsteinMethods.LinearIndex","page":"Index","title":"SuiteSplines.BezierBernsteinMethods.LinearIndex","text":"LinearIndex(P::Degree, D::Dimension, I::Integer)\n\nA linear index I of a simplicial discretization with Degree P and dimension D.\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.BezierBernsteinMethods.LinearIndex-Tuple{NTuple{D, Integer} where D}","page":"Index","title":"SuiteSplines.BezierBernsteinMethods.LinearIndex","text":"LinearIndex(::MultiIndex{X})\n\nCompute the LinearIndex associated with a MultiIndex.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.BezierBernsteinMethods.MultiIndices","page":"Index","title":"SuiteSplines.BezierBernsteinMethods.MultiIndices","text":"MultiIndices(P::Degree, D::Dimension)\nMultiIndices(D::Dimension)\nMultiIndices(s::Simplex)\nMultiIndices(s::BezierSimplex)\n\nReturns an iterator corresponding to a Bezier simplex of polynomial degree P and dimension D.\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.BezierBernsteinMethods.Simplex","page":"Index","title":"SuiteSplines.BezierBernsteinMethods.Simplex","text":" Simplex{D,T<:Real} <: AbstractSimplex{D}\n\nSimplex of dimension D with Vertices in real number type T.\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.IgaBase.dimsplinespace-Tuple{Integer, SuiteSplines.SortedSequences.NonDecreasingVector}","page":"Index","title":"SuiteSplines.IgaBase.dimsplinespace","text":"dimsplinespace(p, U)\n\nCompute the dimension of the spline space defined by degree p and knotsvector U.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.IgaBase.refine-Tuple{Integer, SuiteSplines.IgaBase.hRefinement}","page":"Index","title":"SuiteSplines.IgaBase.refine","text":"refine(p::Degree, R::AbstractRefinement)\n\nChange in polynomial degree based on the refinement type.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.IgaBase.refine-Tuple{SuiteSplines.SortedSequences.NonDecreasingVector, SuiteSplines.IgaBase.hRefinement}","page":"Index","title":"SuiteSplines.IgaBase.refine","text":"refine(p::KnotVector, R::AbstractRefinement)\n\nChange in knot vector based on the refinement type.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.UnivariateSplines.approximate_collocation_inverse-Union{Tuple{T}, Tuple{Int64, SuiteSplines.SortedSequences.NonDecreasingVector{T}}} where T<:Real","page":"Index","title":"SuiteSplines.UnivariateSplines.approximate_collocation_inverse","text":"approximate_collocation_inverse(p, U)\napproximate_collocation_inverse(p, U, k1)\n\nCompute an approximate inverse mathsfA  mathsfB^-1, where mathsfB is the consistent B-spline interpolation matrix. The approximation is of order k_1 leq p+1. The quasi-interpolant is designed to reproduce polynomials\n\n    sum_i=1^n mu_i(x^k) B_ip(x) = x^k  quad textfor  k=01k_1-1\n\nand is based on the following paper\n\nT. Lyche and L. L. Schumaker. Local spline approximation methods. Journal of Approximation Theory, 15(4):294-325, Dec. 1975.\n\nExamples:\n\njulia> p  = Degree(3);\n\njulia> U  = KnotVector([0.0,1.0,1.5,2.5,3.0], [p+1,1,1,2,p+1]);\n\njulia> y  = grevillepoints(p, U);\n\nThe approximate collocation inverse, using full approximation order k_1=p+1 and the consistent collocation matrix are computed as follows\n\njulia> A = approximate_collocation_inverse(p, U, p+1);\n\njulia> B = bspline_interpolation_matrix(p, U, y, 1)[1];\n\nIt can be verified that the quasi-interpolant reproduces constants, linears, quadratic and cubic polynomials\n\njulia> B * A * (y.^0) ≈ y.^0\ntrue\n\njulia> B * A * (y.^1) ≈ y.^1\ntrue\n\njulia> B * A * (y.^2) ≈ y.^2\ntrue\n\njulia> B * A * (y.^3) ≈ y.^3\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.UnivariateSplines.approximate_l2_inverse-Union{Tuple{T}, Tuple{Int64, AbstractVector{T}, Int64}} where T<:Real","page":"Index","title":"SuiteSplines.UnivariateSplines.approximate_l2_inverse","text":"approximate_l2_inverse(p, U, k1)\n\nCompute an approximate inverse mathsfS  mathsfM^-1, where mathsfM is the consisten B-spline mass matrix. The approximation is of order k_1 leq p+1. The L^2 quasi-interpolant is designed to reproduce polynomials\n\n    sum_i=1^n mu_i(x^k) B_ip(x) = x^k  quad textfor  k=01k_1-1\n\nand is based on the following paper\n\nChui, Charles K., Wenjie He, and Joachim Stöckler. \"Nonstationary tight wavelet frames, I: Bounded intervals.\" Applied and Computational Harmonic Analysis 17.2 (2004): 141-197.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.UnivariateSplines.bezier_extraction_operator-Union{Tuple{T}, Tuple{Integer, SuiteSplines.SortedSequences.NonDecreasingVector{T}}} where T<:Real","page":"Index","title":"SuiteSplines.UnivariateSplines.bezier_extraction_operator","text":"bezier_extraction_operator(p, U)\n\nCompute the Bézier extraction operators corresponding to a B-spline basis of polynomial degree p and knot vector U. The output is a 3-dimensional array mathsfC in mathbbR^(p+1) times (p+1) times n_el.\n\nThe implementation is based on the following paper\n\nBorden, Michael J., et al. \"Isogeometric finite element data structures based on Bézier extraction of NURBS.\" International Journal for Numerical Methods in Engineering 87.1‐5 (2011): 15-47.\n\nExamples:\n\njulia> p = Degree(2); U = KnotVector([0.0,0.0,0.0,1.0,3.0,3.0,4.0,4.0,4.0]);\n\njulia> bezier_extraction_operator(p, U)\n3×3×3 Array{Float64, 3}:\n[:, :, 1] =\n 1.0  0.0       0.0\n 0.0  1.0       0.0\n 0.0  0.666667  0.333333\n\n[:, :, 2] =\n 0.666667  0.333333  0.0\n 0.0       1.0       0.0\n 0.0       0.0       1.0\n\n[:, :, 3] =\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.UnivariateSplines.bspline_integral_value-Tuple{Integer, SuiteSplines.SortedSequences.NonDecreasingVector, Integer}","page":"Index","title":"SuiteSplines.UnivariateSplines.bspline_integral_value","text":"bspline_integral_value(p, U, i::Int)\nbspline_integral_value(p, U)\n\nCompute the integral of a b-spline function defined by degree p and knotvector U.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.UnivariateSplines.bspline_interpolation_matrix","page":"Index","title":"SuiteSplines.UnivariateSplines.bspline_interpolation_matrix","text":"bspline_interpolation_matrix(p, U, i, x, nout=1)\n\nGiven the polynomial degree p and knot-vector U compute the collocation matrices of the B-spline basis functions sampled at a set of points x. The output is a set of sparse matrices whose rows correspond to the evaluation points and whose columns are associated with the B-spline degrees of freedom.\n\nExamples:\n\njulia> p = Degree(2);\n\njulia> U = KnotVector([0.0,1.0,1.5,2.5,3.0], [3,1,1,2,3]);\n\njulia> x = IncreasingVector([0.5,1.5,2.75]);\n\njulia> B = bspline_interpolation_matrix(p, U, x, p+1);\n\nThe interpolation matrix for quadratic B-splines is\n\njulia> B[1]\n3×7 SparseArrays.SparseMatrixCSC{Float64, Int64} with 9 stored entries:\n 0.25  0.583333  0.166667   ⋅         ⋅     ⋅    ⋅ \n  ⋅     ⋅        0.666667  0.333333  0.0    ⋅    ⋅ \n  ⋅     ⋅         ⋅         ⋅        0.25  0.5  0.25\n\nThe interpolation matrix for linear and constant B-splines is given by\n\njulia> B[2]\n3×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 6 stored entries:\n 0.5  0.5   ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅   1.0  0.0   ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅   0.5  0.5\n\njulia> B[3]\n3×5 SparseArrays.SparseMatrixCSC{Float64, Int64} with 3 stored entries:\n 1.0   ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅   1.0   ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅   1.0\n\nIt can be easily verified that the B-splines satisfy a partition of unity\n\njulia> sum(B[1],dims=2)\n3×1 Matrix{Float64}:\n 1.0\n 1.0\n 1.0\n\njulia> sum(B[2],dims=2)\n3×1 Matrix{Float64}:\n 1.0\n 1.0\n 1.0\n\njulia> sum(B[3],dims=2)\n3×1 Matrix{Float64}:\n 1.0\n 1.0\n 1.0\n\nThe collocation matrices can be used to solve an interpolation problem or a PDE using the collocation method. For example, the interpolation matrix evaluated at the Greville points can be computed as follows\n\njulia> x = grevillepoints(p, U);\n\njulia> B = bspline_interpolation_matrix(p, U, x, p+1)[1]\n7×7 SparseArrays.SparseMatrixCSC{Float64, Int64} with 21 stored entries:\n 1.0   0.0        0.0        ⋅          ⋅     ⋅    ⋅ \n 0.25  0.583333   0.166667   ⋅          ⋅     ⋅    ⋅ \n  ⋅    0.0833333  0.833333  0.0833333   ⋅     ⋅    ⋅ \n  ⋅     ⋅         0.166667  0.583333   0.25   ⋅    ⋅ \n  ⋅     ⋅          ⋅         ⋅         1.0   0.0  0.0\n  ⋅     ⋅          ⋅         ⋅         0.25  0.5  0.25\n  ⋅     ⋅          ⋅         ⋅         0.0   0.0  1.0\n\nThe matrix mathsfB can then be used to interpolate a univariate function. For example, up to quadratic polynomials are exactly reproduced\n\n# sample grid to test polynomial reproduction\njulia> y = global_insert(x, 4);\n\njulia> C = bspline_interpolation_matrix(p, U, y, 1)[1];\n\njulia> C * (B \\ x.^0) ≈ y.^0\ntrue\n\njulia> C * (B \\ x.^1) ≈ y.^1\ntrue\n\njulia> C * (B \\ x.^2) ≈ y.^2\ntrue\n\nHere matrix mathsfC evaluates the B-spline at a refined partition y.\n\n\n\n\n\n","category":"function"},{"location":"api/#SuiteSplines.UnivariateSplines.bsplinebasisfuns","page":"Index","title":"SuiteSplines.UnivariateSplines.bsplinebasisfuns","text":"bsplinebasisfuns(p, U, i::Integer, x::T, nout=1)\nbsplinebasisfuns(p, U, x::T, nout=1)\n\nCompute the p+1 non-zero B-spline basis-functions at site x in U_iU_i+1). The output is a matrix where column j (rows 1p+2-j), for j=1n_out correspond to the p+2-j non-zero B-spline basis functions of degree p+1-j. The remaining entries correspond to supports. If the active knot-span is not provided then it will be computed.\n\nExamples:\n\njulia> p = Degree(2);\n\njulia> U = KnotVector([0.0,0.0,0.0,1.0,2.0,2.0,2.0]);\n\njulia> x = 1.5\n1.5\n\njulia> span = findspan(p, U, x)\n4\n\njulia> B = bsplinebasisfuns(p, U, span, x, p+1)\n3×3 Matrix{Float64}:\n 0.125  0.5  1.0\n 0.625  0.5  1.0\n 0.25   1.0  2.0\n\nThe knot span index can be omited, in which case it is computed on the fly.\n\njulia> bsplinebasisfuns(p, U, x, p+1)\n3×3 Matrix{Float64}:\n 0.125  0.5  1.0\n 0.625  0.5  1.0\n 0.25   1.0  2.0\n\nBy prescribing a vector of m sites x in mathbbR^m we can compute the B-splines at more than one point. The function can be called with or without prescribing the knot-span index\n\nbsplinebasisfuns(p, U, span::Vector{Integer}, u::Vector{T}, nout=1)\nbsplinebasisfuns(p, U, u::SortedSequence{T}, nout=1)\n\nThe output is a 3-dimensional array B in mathbbR^(p+1) times m times n_out.\n\nExamples:\n\njulia> x = IncreasingVector([0.5, 1.5]);\n\njulia> span = findspan(p, U, x)\n2-element NonDecreasingVector{Int64}:\n 3\n 4\n\njulia> bsplinebasisfuns(p, U, span, x, p+1)\n3×2×3 Array{Float64, 3}:\n[:, :, 1] =\n 0.25   0.125\n 0.625  0.625\n 0.125  0.25\n\n[:, :, 2] =\n 0.5  0.5\n 0.5  0.5\n 2.0  1.0\n\n[:, :, 3] =\n 1.0  1.0\n 1.0  1.0\n 1.0  2.0\n\nAlternatively, the non-vanishing B-splines up to and including degree p can be computed at n_el non-zero knot-spans (elements) with m sites each, that is, x in mathbbR^m times n_el. Again, the function can be called with or without prescribing the knot-span index\n\nbsplinebasisfuns(p, U, span::Vector{Int64}, u::Matrix{T}, nout=1)\nbsplinebasisfuns(p, U, u::Matrix{T}, nout=1)\n\nThe output is a 4-dimensional array B in mathbbR^(p+1) times m times n_el times n_out.\n\nExamples:\n\njulia> x = [0.25 1.25;\n            0.75 1.75];\n\njulia> bsplinebasisfuns(p, U, x, p+1)\n3×2×2×3 Array{Float64, 4}:\n[:, :, 1, 1] =\n 0.5625   0.0625\n 0.40625  0.65625\n 0.03125  0.28125\n\n[:, :, 2, 1] =\n 0.28125  0.03125\n 0.65625  0.40625\n 0.0625   0.5625\n\n[:, :, 1, 2] =\n 0.75  0.25\n 0.25  0.75\n 2.0   2.0\n\n[:, :, 2, 2] =\n 0.75  0.25\n 0.25  0.75\n 1.0   1.0\n\n[:, :, 1, 3] =\n 1.0  1.0\n 1.0  1.0\n 1.0  1.0\n\n[:, :, 2, 3] =\n 1.0  1.0\n 1.0  1.0\n 2.0  2.0\n\n\n\n\n\n","category":"function"},{"location":"api/#SuiteSplines.UnivariateSplines.ders_bspline_interpolation_matrix","page":"Index","title":"SuiteSplines.UnivariateSplines.ders_bspline_interpolation_matrix","text":"ders_bspline_interpolation_matrix(p, U, i, x, nout=1)\n\nGiven the polynomial degree p and knot-vector U compute the collocation matrices of the first n_out derivatives of the B-spline basis functions sampled at a set of points x. The output is a set of sparse matrices whose rows correspond to the evaluation points and whose columns are associated with the B-spline degrees of freedom.\n\nExamples:\n\njulia> p = Degree(2);\n\njulia> U = KnotVector([0.0,1.0,1.5,2.5,3.0], [3,1,1,2,3]);\n\njulia> x = IncreasingVector([0.5,1.5,2.75]);\n\njulia> B = ders_bspline_interpolation_matrix(p, U, x, p+1);\n\nThe output is a set of SparseMatrixCSC matrices. For example the B-splines evaluate at points x are\n\njulia> B[1]\n3×7 SparseArrays.SparseMatrixCSC{Float64, Int64} with 9 stored entries:                       \n 0.25  0.583333  0.166667   ⋅         ⋅     ⋅    ⋅                                            \n  ⋅     ⋅        0.666667  0.333333  0.0    ⋅    ⋅                                            \n  ⋅     ⋅         ⋅         ⋅        0.25  0.5  0.25                                          \n\nDerivatives of quadratic B-splines evaluated at x\n\njulia> B[2]\n3×7 SparseArrays.SparseMatrixCSC{Float64, Int64} with 9 stored entries:\n -1.0  0.333333   0.666667   ⋅         ⋅    ⋅    ⋅ \n   ⋅    ⋅        -1.33333   1.33333   0.0   ⋅    ⋅ \n   ⋅    ⋅          ⋅         ⋅       -2.0  0.0  2.0\n\nSecond derivatives of quadratic B-splines evaluated at x\n\njulia> B[3]\n3×7 SparseArrays.SparseMatrixCSC{Float64, Int64} with 9 stored entries:\n 2.0  -3.33333  1.33333    ⋅        ⋅      ⋅    ⋅ \n  ⋅     ⋅       1.33333  -3.33333  2.0     ⋅    ⋅ \n  ⋅     ⋅        ⋅         ⋅       8.0  -16.0  8.0\n\n\n\n\n\n","category":"function"},{"location":"api/#SuiteSplines.UnivariateSplines.dersbsplinebasisfuns","page":"Index","title":"SuiteSplines.UnivariateSplines.dersbsplinebasisfuns","text":"dersbsplinebasisfuns(p, U, span::Int, u::T, nout=1)\ndersbsplinebasisfuns(p, U, u::T, nout=1)\n\nCompute the non-vanishing B-spline basis-functions of degree p and their n_out-1'th order derivatives at the site x. The output is a matrix B in mathbbR^(p+1) times n_out where the i'th row corresponds to the i'th non-vanishing B-spline at x and the j'th column corresponds to the j-1'th derivative.\n\nThe implementation of this function is based on\n\nPiegl, Les, and Wayne Tiller. The NURBS book. Springer Science & Business Media, 2012.\n\nExamples:\n\njulia> p = Degree(2);\n\njulia> U = KnotVector([0.0,0.0,0.0,1.0,2.0,2.0,2.0]);\n\njulia> x = 1.5;\n\njulia> span = findspan(p, U, x)\n4\n\njulia> dersbsplinebasisfuns(p, U, span, x, p+1)\n3×3 Matrix{Float64}:\n 0.125  -0.5   1.0\n 0.625  -0.5  -3.0\n 0.25    1.0   2.0\n\ndersbsplinebasisfuns can also be called without providing the span-indices, in which case they will be calculated on the fly.\n\njulia> dersbsplinebasisfuns(p, U, x, p+1)\n3×3 Matrix{Float64}:\n 0.125  -0.5   1.0\n 0.625  -0.5  -3.0\n 0.25    1.0   2.0\n\nBy prescribing a vector of m sites x in mathbbR^m we can compute the B-splines and their derivatives at more than one point.  The function can be called with or without prescribing the knot-span index\n\ndersbsplinebasisfuns(p, U, span::Vector{Integer}, u::Vector{T}, nout=1)\ndersbsplinebasisfuns(p, U, u::SortedSequence{T}, nout=1)\n\nThe output is a 3-dimensional array B in mathbbR^(p+1) times m times n_out.\n\nExamples:\n\njulia> x = IncreasingVector([0.5, 1.5]);\n\njulia> span = findspan(p, U, x)\n2-element NonDecreasingVector{Int64}:\n 3\n 4\n\njulia> dersbsplinebasisfuns(p, U, span, x, p+1)\n3×2×3 Array{Float64, 3}:\n[:, :, 1] =\n 0.25   0.125\n 0.625  0.625\n 0.125  0.25\n\n[:, :, 2] =\n -1.0  -0.5\n  0.5  -0.5\n  0.5   1.0\n\n[:, :, 3] =\n  2.0   1.0\n -3.0  -3.0\n  1.0   2.0\n\nAlternatively, the non-vanishing derivatives of the B-splines can be computed at n_el non-zero knot-spans (elements) with m sites each, that is, x in mathbbR^m times n_el. Again, the function can be called with or without prescribing the knot-span index\n\ndersbsplinebasisfuns(p, U, span::Vector{Int64}, u::Matrix{T}, nout=1)\ndersbsplinebasisfuns(p, U, u::Matrix{T}, nout=1)\n\nThe output is a 4-dimensional array B in mathbbR^(p+1) times m times n_el times n_out.\n\nExamples:\n\njulia> x = [0.25 1.25;\n            0.75 1.75];\n\njulia> dersbsplinebasisfuns(p, U, x, p+1)\n3×2×2×3 Array{Float64, 4}:\n[:, :, 1, 1] =\n 0.5625   0.0625\n 0.40625  0.65625\n 0.03125  0.28125\n\n[:, :, 2, 1] =\n 0.28125  0.03125\n 0.65625  0.40625\n 0.0625   0.5625\n\n[:, :, 1, 2] =\n -1.5   -0.5\n  1.25  -0.25\n  0.25   0.75\n\n[:, :, 2, 2] =\n -0.75  -0.25\n  0.25  -1.25\n  0.5    1.5\n\n[:, :, 1, 3] =\n  2.0   2.0\n -3.0  -3.0\n  1.0   1.0\n\n[:, :, 2, 3] =\n  1.0   1.0\n -3.0  -3.0\n  2.0   2.0\n\n\n\n\n\n","category":"function"},{"location":"api/#SuiteSplines.UnivariateSplines.distribute_points-Tuple{SuiteSplines.UnivariateSplines.SplineSpace, SuiteSplines.UnivariateSplines.SplineSpace}","page":"Index","title":"SuiteSplines.UnivariateSplines.distribute_points","text":"distribute_points(S::SplineSpace, V::SplineSpace; add_boundary_points::Bool=false)\n\nCompute distribution of quadrature points in weigthed quadrature with a test-space V and target space for quadrature S. The nodes are distribute in such a way that all conditions for exact quadrature are satisfied with a minimum number of points.\n\nThe distribution of quadrature points in weighted quadrature is based on the following paper.\n\nHiemstra, René R., et al. \"Fast formation and assembly of finite element matrices with application to isogeometric linear elasticity.\" Computer Methods in Applied Mechanics and Engineering 355 (2019): 234-260.\n\nExamples:\n\njulia> S = SplineSpace(2, IncreasingVector([0.0,1.0,2.0,3.0]), [3,2,2,3]);\n\njulia> V = SplineSpace(2, IncreasingVector([0.0,1.0,2.0,3.0]), [3,1,1,3]);\n\njulia> UnivariateSplines.distribute_points(S, V)\n8-element IncreasingVector{Float64}:\n 0.16666666666666666\n 0.5\n 0.8333333333333334\n 1.25\n 1.75\n 2.1666666666666665\n 2.5\n 2.8333333333333335\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.UnivariateSplines.extraction_operator-Tuple{Integer, SuiteSplines.SortedSequences.NonDecreasingVector}","page":"Index","title":"SuiteSplines.UnivariateSplines.extraction_operator","text":"extraction_operator(p::Degree, U::KnotVector; [cperiodic, cleft, cright])\n\nCompute an extraction operator that creates a subspace of the SplineSpace with for example peroidicity built-in.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.UnivariateSplines.findspan-Union{Tuple{T}, Tuple{Integer, SuiteSplines.SortedSequences.NonDecreasingVector{T}, T}} where T<:Real","page":"Index","title":"SuiteSplines.UnivariateSplines.findspan","text":"findspan(p, U, u)\n\nGiven polynomial degree p and knotvector U determine the knot span index i of a point x such that u in U_i U_i+1).\n\nExamples:\n\njulia> p = Degree(2)\n2\n\njulia> U = KnotVector([0.0,1.0,1.5,2.5,3.0],[3,1,1,2,3])\n10-element NonDecreasingVector{Float64}:\n 0.0\n 0.0\n 0.0\n 1.0\n 1.5\n 2.5\n 2.5\n 3.0\n 3.0\n 3.0\n\njulia> x = 2.0\n2.0\n\njulia> span = findspan(p, U, x)\n5\n\njulia> U[span] ≤ x < U[span+1]\ntrue\n\nIt is also possible to compute the knot-spans of all values in an 'IncreasingVector{T}'\n\njulia> x = IncreasingVector([0.25, 0.75, 1.0, 1.25, 2.5, 2.75]);\n\njulia> span = findspan(p, U, x)\n6-element NonDecreasingVector{Int64}:\n 3\n 3\n 4\n 4\n 7\n 7\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.UnivariateSplines.grevillepoints-Tuple{Integer, SuiteSplines.SortedSequences.NonDecreasingVector, Integer}","page":"Index","title":"SuiteSplines.UnivariateSplines.grevillepoints","text":"grevillepoints(p, U, i)\ngrevillepoints(p, U)\n\nCompute the i'th Greville Absissa corresponding to the i'th B-spline defined by degree 'p' and knotvector 'U' of spline space.\n\nExamples:\n\njulia> p = Degree(2);\n\njulia> U = KnotVector([0.0,1.0,2.5,3.0], [3,1,2,1])\n7-element NonDecreasingVector{Float64}:\n 0.0\n 0.0\n 0.0\n 1.0\n 2.5\n 2.5\n 3.0\n\njulia> grevillepoints(p, U, 2)\n0.5\n\njulia> grevillepoints(p, U)\n4-element IncreasingVector{Float64}:\n 0.0\n 0.5\n 1.75\n 2.5\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.UnivariateSplines.h_refinement_operator!-Union{Tuple{T}, Tuple{Integer, SuiteSplines.SortedSequences.NonDecreasingVector{T}, Integer, T}} where T<:Real","page":"Index","title":"SuiteSplines.UnivariateSplines.h_refinement_operator!","text":"h_refinement_operator!(p::Degree, U::KnotVector{T}, u::AbstractVector{T}) where {T<:Real}\nh_refinement_operator!(p::Degree, U::KnotVector{T}, u::T) where {T<:Real}\nh_refinement_operator!(p::Degree, U::KnotVector{T}, span::Integer, u::T) where {T<:Real}\n\nInsert one or more knots u into knotvector U and output the transformation operator from the coarse to the refined space. The knotvector is updated in-place. The output is represented as a SparseMatrixCSC matrix.\n\nExamples:\n\njulia> p = Degree(2)\n2\n\njulia> U = KnotVector([0.0,1.0,2.0,3.0,4], [3,1,1,2,3])\n10-element NonDecreasingVector{Float64}:\n 0.0\n 0.0\n 0.0\n 1.0\n 2.0\n 3.0\n 3.0\n 4.0\n 4.0\n 4.0\n\njulia> C = h_refinement_operator!(p, U, [0.5, 1.5, 2.5, 3.5]); # sparse matrix\n\njulia> Matrix(C)\n11×7 Matrix{Float64}:\n 1.0  0.0   0.0   0.0   0.0  0.0  0.0\n 0.5  0.5   0.0   0.0   0.0  0.0  0.0\n 0.0  0.75  0.25  0.0   0.0  0.0  0.0\n 0.0  0.25  0.75  0.0   0.0  0.0  0.0\n 0.0  0.0   0.75  0.25  0.0  0.0  0.0\n 0.0  0.0   0.25  0.75  0.0  0.0  0.0\n 0.0  0.0   0.0   0.5   0.5  0.0  0.0\n 0.0  0.0   0.0   0.0   1.0  0.0  0.0\n 0.0  0.0   0.0   0.0   0.5  0.5  0.0\n 0.0  0.0   0.0   0.0   0.0  0.5  0.5\n 0.0  0.0   0.0   0.0   0.0  0.0  1.0\n\njulia> @show U;\nU = [0.0, 0.0, 0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.0, 3.5, 4.0, 4.0, 4.0]\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.UnivariateSplines.normalization_weights-Union{Tuple{SuiteSplines.SortedSequences.IncreasingVector{T}}, Tuple{T}} where T<:Real","page":"Index","title":"SuiteSplines.UnivariateSplines.normalization_weights","text":"normalization_weights(X)\n\nDetermine a set of normalization weights that result in a more uniform set oftype( weighted quadrature weights when solving for the least norm solution. )\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.UnivariateSplines.nquadpoints-Tuple{SuiteSplines.UnivariateSplines.SplineSpace, SuiteSplines.UnivariateSplines.SplineSpace}","page":"Index","title":"SuiteSplines.UnivariateSplines.nquadpoints","text":"nquadpoints(S::SplineSpace, V::SplineSpace; add_boundary_points=false, add_additional_points=0, min_points=1)\n\nDetermine the minimum number of quadrature points corresponding to a weighted quadrature rule with test-space V and target-space S.\n\nExamples:\n\njulia> S = SplineSpace(2, IncreasingVector([0.0,1.0,2.0,3.0]), [3,2,2,3]);\n\njulia> V = SplineSpace(2, IncreasingVector([0.0,1.0,2.0,3.0]), [3,1,1,3]);\n\njulia> A = UnivariateSplines.nquadpoints(S, V; add_boundary_points=false)\n3-element Vector{Int64}:\n 3\n 2\n 3\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.UnivariateSplines.num_elements-Tuple{SuiteSplines.SortedSequences.NonDecreasingVector}","page":"Index","title":"SuiteSplines.UnivariateSplines.num_elements","text":"num_elements(U::KnotVector)\n\nCount the number of non-zero knot spans or elements in the knotvector.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.UnivariateSplines.onebasisfuneval-Union{Tuple{T}, Tuple{SuiteSplines.SortedSequences.NonDecreasingVector{T}, T}} where T<:Real","page":"Index","title":"SuiteSplines.UnivariateSplines.onebasisfuneval","text":"onebasisfuneval(U, u)\n\nCompute value of a single B-spline basis-function defined by local knotvector 'U' evaluated at point 'x'.\n\nThe implementation of this function is taken from\n\nPiegl, Les, and Wayne Tiller. The NURBS book. Springer Science & Business Media, 2012.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.UnivariateSplines.refinement_operator-Tuple{Integer, SuiteSplines.SortedSequences.NonDecreasingVector, SuiteSplines.IgaBase.AbstractRefinement}","page":"Index","title":"SuiteSplines.UnivariateSplines.refinement_operator","text":"refinement_operator(p::Degree, U::KnotVector, method::AbstractRefinement)\n\nCompute the two_scale_operator given p and U and the applicable refinement strategy: IgaBase.hRefinement(), IgaBase.pRefinement(), IgaBase.kRefinement(). See IgaBase package for definition of refinement methods.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.UnivariateSplines.solve_leastnorm_without_constraints-Union{Tuple{T}, Tuple{Matrix{T}, Vector{T}}, Tuple{Matrix{T}, Vector{T}, Any}} where T<:Real","page":"Index","title":"SuiteSplines.UnivariateSplines.solve_leastnorm_without_constraints","text":"solve_leastnorm_without_constraints(A, b, S=BigFloat)\n\nSolve underdetermined system of equation A x = b using QR factorization with arbitrary precision.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.UnivariateSplines.table_required_points-Tuple{SuiteSplines.UnivariateSplines.SplineSpace, SuiteSplines.UnivariateSplines.SplineSpace}","page":"Index","title":"SuiteSplines.UnivariateSplines.table_required_points","text":"table_required_points(S, V)\n\nDetermine the number of exactness conditions in subsets of elements. The output is a matrix mathsfA where mathsfA_ij denotes the minimum number of points required in interval ij to perform exact weighted quadrature.\n\nExamples:\n\njulia> S = SplineSpace(2, IncreasingVector([0.0,1.0,2.0,3.0]), [3,2,2,3]);\n\njulia> V = SplineSpace(2, IncreasingVector([0.0,1.0,2.0,3.0]), [3,1,1,3]);\n\njulia> A = UnivariateSplines.table_required_points(S, V)\n3×3×1 Array{Int64, 3}:\n[:, :, 1] =\n 3  5  7\n 2  5  0\n 3  0  0\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.UnivariateSplines.two_scale_operator-Union{Tuple{T}, Tuple{Integer, SuiteSplines.SortedSequences.NonDecreasingVector{T}, Integer, SuiteSplines.SortedSequences.NonDecreasingVector{T}}} where T<:Real","page":"Index","title":"SuiteSplines.UnivariateSplines.two_scale_operator","text":"two_scale_operator(p::Degree, U::KnotVector{T}, q::Degree, V::KnotVector{T}) where {T<:Real}\n\nThe two_scale_operator encodes the main logic for all spline refinemement operations.\n\nThe arguments p and U correspond to the current spline space and q and V are the \"target\" degree knot vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.UnivariateSplines.unit_integral_rescaling-Tuple{Integer, SuiteSplines.SortedSequences.NonDecreasingVector, Integer}","page":"Index","title":"SuiteSplines.UnivariateSplines.unit_integral_rescaling","text":"unit_integral_rescaling(p, U, i::Int)\nunit_integral_rescaling(p, U)\n\nCompute the scaling factors that normalize the B-spline basis functions to have unit integral.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.UnivariateSplines.wquadweights!-Union{Tuple{T}, Tuple{SparseArrays.SparseMatrixCSC{T}, SparseArrays.SparseMatrixCSC{T}, SparseArrays.SparseMatrixCSC{T}, Vector{T}}} where T<:Real","page":"Index","title":"SuiteSplines.UnivariateSplines.wquadweights!","text":"wquadweights!(M, B, W, C)\n\nCompute the quadrature weights in weighted quadrature such that M ≈ W' * B.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.UnivariateSplines.Bspline","page":"Index","title":"SuiteSplines.UnivariateSplines.Bspline","text":"Bspline{T} <: ScalarMapping{1}\n\nA univariate B-spline function of field T.\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.UnivariateSplines.BsplineBasis","page":"Index","title":"SuiteSplines.UnivariateSplines.BsplineBasis","text":"BsplineBasis{T<:Real} <: Basis{T,3}\n\nSpecial array type for storing evaluating B-spline and their derivatives.\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.UnivariateSplines.BsplineEvaluationCache","page":"Index","title":"SuiteSplines.UnivariateSplines.BsplineEvaluationCache","text":"BsplineEvaluationCache <: EvaluationCache{1}\n\nCache that caches basis function evaluation at a set of evaluation points.\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.UnivariateSplines.BsplineSupport","page":"Index","title":"SuiteSplines.UnivariateSplines.BsplineSupport","text":"BsplineSupport(S::SplineSpace)\n\nIterator that outputs the supporting elements of each B-spline basis-function as a UnitRange{Int64}.\n\nExample:\n\njulia> S = SplineSpace(2, [0.0,2.0,3.0], [3,1,3]);\n\njulia> for α in BsplineSupport(S)\n           @show α\n       end\nα = 1:1\nα = 1:2\nα = 1:2\nα = 2:2\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.UnivariateSplines.GeneralizedGaussrule","page":"Index","title":"SuiteSplines.UnivariateSplines.GeneralizedGaussrule","text":"GeneralizedGaussrule(p, r, nel, a, b)\n\nCompute a generalized Gaussian quadrature rule for a target spline-space mathbbS^p_r(ab) defined in a uniform partition with n_el elements.\n\nThese rules are made available in the following paper\n\nHiemstra, René R., et al. \"Optimal and reduced quadrature rules for tensor product and hierarchically refined splines in isogeometric analysis.\" Computer Methods in Applied Mechanics and Engineering 316 (2017): 966-1004.\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.UnivariateSplines.KnotSpanIndices","page":"Index","title":"SuiteSplines.UnivariateSplines.KnotSpanIndices","text":"KnotSpanIndices\n\nA sorted sequence of integers that refer to the corresponding non-zero knot span of a KnotVector.\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.UnivariateSplines.KnotVector","page":"Index","title":"SuiteSplines.UnivariateSplines.KnotVector","text":"KnotVector{T<:Real}\n\nA knot-vector is a non-decreasing sequence of real numbers. (typeallias of NonDecreasingVector{T})\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.UnivariateSplines.SpanIndex","page":"Index","title":"SuiteSplines.UnivariateSplines.SpanIndex","text":"SpanIndex(S::SplineSpace)\n\nIterator that outputs the span index corresponding to each element in the partition\n\nExample:\n\njulia> S = SplineSpace(2, [0.0,1.0,2.0,3.0,4.0], [3,1,2,1,3]);\n\njulia> for s in SpanIndex(S)\n           @show s\n       end\ns = 3\ns = 4\ns = 6\ns = 7\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.UnivariateSplines.SplineSpace","page":"Index","title":"SuiteSplines.UnivariateSplines.SplineSpace","text":"SplineSpace(p, U)\nSplineSpace(p, x, m)\nSplineSpace(p, Interval(a, b), num_elements)\n\nDefinition of a spline space by means of the polynomial degree p, a sequence of break-points x and the knot-multiplicity m or by prescribing the knot-vector U.\n\nExamples:\n\njulia> S = SplineSpace(2, [0.0,2.0,3.0], [3,1,3])\nSplineSpace(degree = 2, interval = [0.0, 3.0], dimension = 4)\n\njulia> dimsplinespace(S)\n4\n\njulia> Degree(S)\n2\n\njulia> KnotVector(S)\n7-element NonDecreasingVector{Float64}:\n 0.0\n 0.0\n 0.0\n 2.0\n 3.0\n 3.0\n 3.0\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.UnivariateSplines.Support","page":"Index","title":"SuiteSplines.UnivariateSplines.Support","text":"BsplineSupport(S::SplineSpace)\n\nIterator that outputs the supporting elements of each B-spline basis-function as a UnitRange{Int64}.\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.UnivariateSplines.WeightedQuadrule","page":"Index","title":"SuiteSplines.UnivariateSplines.WeightedQuadrule","text":"WeightedQuadrule{T<:Real} <: AbstractQuadrule{1}\n\nWeighted quadrature rules are test function specific quadrature rules that exactly integrate all functions in a targetspace. The rules are computed in high precision and are accurate up to 16 digits.\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.IgaBase.QuadratureRule-Union{Tuple{SuiteSplines.CartesianProducts.TensorProduct{Dim, <:SuiteSplines.IgaBase.AbstractQuadrule{1}}}, Tuple{Dim}} where Dim","page":"Index","title":"SuiteSplines.IgaBase.QuadratureRule","text":"QuadratureRule(Q::TensorProduct{Dim,<:AbstractQuadrule{1}})\n\nGenerate a tensor product quadrature rule where the quadrature points are stored as a CartesianProduct and the weights as a KroneckerProduct vector allowing for easy evaluation and numerical integration based on Kronecker products.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.TensorProductBsplines.TPEvaluationCache","page":"Index","title":"SuiteSplines.TensorProductBsplines.TPEvaluationCache","text":"TPEvaluationCache{Dim}\n\nType that caches spline basis functions as a KroneckerProduct{Dim} and a grid of points as a CartesianProduct{Dim}. The type is mutable such that the cached variables can be updated at runtime.\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.TensorProductBsplines.TensorProductBspline","page":"Index","title":"SuiteSplines.TensorProductBsplines.TensorProductBspline","text":"TensorProductBspline{Dim,Ders,T}(space, coeffs)\nTensorProductBspline{Dim,Ders,T}(space; codim=1)\n\nConstruct a Dim dimensional TensorProductBspline patch that is mapped to Codim dimensional Euclidean space.\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.IgaFormation.QuadraturePoints-Tuple{SuiteSplines.IgaFormation.ElementAccessor, SuiteSplines.IgaFormation.Element}","page":"Index","title":"SuiteSplines.IgaFormation.QuadraturePoints","text":"QuadraturePoints(acc::ElementAccessor{Dim}, element::Element{Dim}) where Dim\n\nGet the quadrature points on this element.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.IgaFormation.QuadraturePoints-Tuple{SuiteSplines.IgaFormation.PatchAccessor}","page":"Index","title":"SuiteSplines.IgaFormation.QuadraturePoints","text":"QuadraturePoints(acc::PatchAccessor{Dim}) where Dim\n\nGet the quadrature points on this element.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.IgaFormation.QuadratureWeights-Tuple{SuiteSplines.IgaFormation.ElementAccessor, SuiteSplines.IgaFormation.Element}","page":"Index","title":"SuiteSplines.IgaFormation.QuadratureWeights","text":"QuadratureWeights(acc::ElementAccessor{Dim}, element::Element{Dim}) where Dim\n\nGet the quadrature weights on this element.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.IgaFormation.QuadratureWeights-Tuple{SuiteSplines.IgaFormation.PatchAccessor}","page":"Index","title":"SuiteSplines.IgaFormation.QuadratureWeights","text":"QuadratureWeights(acc::PatchAccessor{Dim}) where Dim\n\nGet the quadrature weights on this element.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.IgaFormation.TestFunctions-Tuple{SuiteSplines.IgaFormation.ElementAccessor, SuiteSplines.IgaFormation.Element}","page":"Index","title":"SuiteSplines.IgaFormation.TestFunctions","text":"TestFunctions(acc::ElementAccessor{Dim}, element::Element{Dim}) where Dim\n\nGet the test functions on an element as a KroneckerProduct matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.IgaFormation.TestFunctions-Tuple{SuiteSplines.IgaFormation.PatchAccessor}","page":"Index","title":"SuiteSplines.IgaFormation.TestFunctions","text":"TestFunctions(acc::PatchAccessor{Dim}) where Dim\n\nGet the test functions on the patch as a KroneckerProduct matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.IgaFormation.TestIndices-Tuple{SuiteSplines.IgaFormation.ElementAccessor}","page":"Index","title":"SuiteSplines.IgaFormation.TestIndices","text":"TestIndices(acc::PatchtAccessor)\n\nGet global indices of the test functions.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.IgaFormation.TestIndices-Union{Tuple{Dim}, Tuple{SuiteSplines.IgaFormation.ElementAccessor{Dim}, SuiteSplines.IgaFormation.Element{Dim}}} where Dim","page":"Index","title":"SuiteSplines.IgaFormation.TestIndices","text":"TestIndices(acc::ElementAccessor{Dim}, element::Element{Dim})\n\nGet global indices of the test functions on an element.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.IgaFormation.TrialFunctions-Tuple{SuiteSplines.IgaFormation.ElementAccessor, SuiteSplines.IgaFormation.Element}","page":"Index","title":"SuiteSplines.IgaFormation.TrialFunctions","text":"TrialFunctions(acc::ElementAccessor{Dim}, element::Element{Dim})\n\nGet the trial functions on an element as a KroneckerProduct matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.IgaFormation.TrialFunctions-Tuple{SuiteSplines.IgaFormation.PatchAccessor}","page":"Index","title":"SuiteSplines.IgaFormation.TrialFunctions","text":"TrialFunctions(acc::PatchAccessor)\n\nGet the trial functions on the patch as a KroneckerProduct matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.IgaFormation.TrialIndices-Tuple{SuiteSplines.IgaFormation.ElementAccessor}","page":"Index","title":"SuiteSplines.IgaFormation.TrialIndices","text":"TrialIndices(acc::PatchAccessor)\n\nGet global indices of the trial functions.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.IgaFormation.TrialIndices-Union{Tuple{Dim}, Tuple{SuiteSplines.IgaFormation.ElementAccessor{Dim}, SuiteSplines.IgaFormation.Element{Dim}}} where Dim","page":"Index","title":"SuiteSplines.IgaFormation.TrialIndices","text":"TrialIndices(acc::ElementAccessor{Dim}, element::Element{Dim})\n\nGet global indices of the trial functions on an element.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.IgaFormation.coface-Tuple{SuiteSplines.IgaFormation.Element}","page":"Index","title":"SuiteSplines.IgaFormation.coface","text":"coface(element::Element)\n\nIf element is on the boundary then element.parent is a view and this function returns its single co-face.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.IgaFormation.pre_allocate_arrays-Tuple{Any, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}}","page":"Index","title":"SuiteSplines.IgaFormation.pre_allocate_arrays","text":"pre_allocate_arrays(T, nquad::NTuple{3,Int}, m::NTuple{3,Int}, n::NTuple{3,Int})\n\nPreallocate arrays of element type==T for use in sum factorization of matrices.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.IgaFormation.pre_allocate_arrays-Tuple{Any, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}}","page":"Index","title":"SuiteSplines.IgaFormation.pre_allocate_arrays","text":"pre_allocate_arrays(T, nquad::NTuple{3,Int}, m::NTuple{3,Int})\n\nPreallocate arrays of element type==T for use in sum factorization of vectors.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.IgaFormation.pre_allocate_arrays-Tuple{Any, Tuple{Int64, Int64}, Tuple{Int64, Int64}, Tuple{Int64, Int64}}","page":"Index","title":"SuiteSplines.IgaFormation.pre_allocate_arrays","text":"pre_allocate_arrays(T, nquad::NTuple{2,Int}, m::NTuple{2,Int}, n::NTuple{2,Int})\n\nPreallocate arrays of element type==T for use in sum factorization of matrices.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.IgaFormation.pre_allocate_arrays-Tuple{Any, Tuple{Int64, Int64}, Tuple{Int64, Int64}}","page":"Index","title":"SuiteSplines.IgaFormation.pre_allocate_arrays","text":"pre_allocate_arrays(T, nquad::NTuple{2,Int}, m::NTuple{2,Int})\n\nPreallocate arrays of element type==T for use in sum factorization of vectors.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.IgaFormation.sumfact!-Tuple{Tuple{DenseArray, DenseArray, DenseArray}, Any, Any}","page":"Index","title":"SuiteSplines.IgaFormation.sumfact!","text":"sumfact!(A::Tuple{<:Array,<:Array,<:Array}, C, testfuns)\n\nApply sum factorization. A and B are allocated using pre_allocate_arrays(...). testfuns and trialfuns are tuples of arrays that represent the test and trial functions evaluated at the quadrature nodes. It is assumed that the quadrature weights have been  incorporated into the test functions.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.IgaFormation.sumfact!-Tuple{Tuple{DenseArray, DenseArray, DenseArray}, Vararg{Any, 4}}","page":"Index","title":"SuiteSplines.IgaFormation.sumfact!","text":"sumfact!(A::Tuple{<:Array,<:Array,<:Array}, B, C, testfuns, trialfuns)\n\nApply sum factorization. A and B are allocated using pre_allocate_arrays(...). testfuns and trialfuns are tuples of arrays that represent the test and trial functions evaluated at the quadrature nodes. It is assumed that the quadrature weights have been  incorporated into the test functions\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.IgaFormation.sumfact!-Tuple{Tuple{DenseArray, DenseArray}, Any, Any}","page":"Index","title":"SuiteSplines.IgaFormation.sumfact!","text":"sumfact!(A::Tuple{<:Array,<:Array}, C, testfuns)\n\nApply sum factorization. A is pre-allocated using pre_allocate_rhs_arrays(...). testfuns is a tuple of matrices that represent the test functions evaluated at  the quadrature nodes. It is assumed that the quadrature weights have been incorporated into the test functions.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.IgaFormation.sumfact!-Tuple{Tuple{DenseArray, DenseArray}, Vararg{Any, 4}}","page":"Index","title":"SuiteSplines.IgaFormation.sumfact!","text":"sumfact!(A::Tuple{<:Array,<:Array}, B, C, testfuns, trialfuns)\n\nApply sum factorization. A and B are allocated using pre_allocate_arrays(...). testfuns and trialfuns are tuples of arays that represent the test and trial functions evaluated at the quadrature nodes. It is assumed that the quadrature weights have been  incorporated into the test functions.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.IgaBase.QuadratureRule-Tuple{SuiteSplines.IgaFormation.ElementAccessor, SuiteSplines.IgaFormation.Element}","page":"Index","title":"SuiteSplines.IgaBase.QuadratureRule","text":"QuadratureRule(acc::ElementAccessor{Dim}, element::Element{Dim}) where Dim\n\nGet the quadrature rule on this element.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.IgaBase.QuadratureRule-Tuple{SuiteSplines.IgaFormation.PatchAccessor}","page":"Index","title":"SuiteSplines.IgaBase.QuadratureRule","text":"QuadratureRule(acc::PatchAccessor{Dim}) where Dim\n\nGet the quadrature rule on the patch.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.IgaFormation.Element","page":"Index","title":"SuiteSplines.IgaFormation.Element","text":"Element{Dim, T}\n\nDim-dimensional element storing its domain of definition as a Cartesian{Dim, Interval{T}} and its element number as a  CartesianIndex{Dim}\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.IgaFormation.ElementAccessor","page":"Index","title":"SuiteSplines.IgaFormation.ElementAccessor","text":"ElementAccessor{Dim, X<:IncreasingSequence, Data}\n\nDatastructure that provides access to element data such as the element domain, element trialfunctions, element testfunctions and element quadrature rule.\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.IgaFormation.Elements","page":"Index","title":"SuiteSplines.IgaFormation.Elements","text":"Elements(partition::CartesianProduct{Dim, <:IncreasingSequence{<:Real}})\n\nReturn an iterator over all elements in a partition.\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.IgaFormation.PatchAccessor","page":"Index","title":"SuiteSplines.IgaFormation.PatchAccessor","text":"PatchAccessor{Dim, X, ..., Data}\n\nDatastructure that provides access to element data such as the element domain, element trialfunctions, element testfunctions and element quadrature rule.\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.IgaFormation.UnivariatePatchData","page":"Index","title":"SuiteSplines.IgaFormation.UnivariatePatchData","text":"UnivariatePatchData{T<:Real, Q<:AbstractQuadrule{1}}\n\nDatastructure that stores all the univariate patch data. This data is conveniently accessed by an element accessor.\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.ImmersedSplines.active_splines-Tuple{SuiteSplines.CartesianProducts.TensorProduct{2, <:SuiteSplines.UnivariateSplines.SplineSpace}, Matrix{Int8}}","page":"Index","title":"SuiteSplines.ImmersedSplines.active_splines","text":"active_splines(U::TensorProduct{2, <:SplineSpace}, E::Array)\n\nDetermine the active B-splines and boundary B-splines given a  distance function ϕ.\n\nA[k] == 0 => no physical elements in support of the function A[k] == 1 => boundary function with a physical cut element in its support A[k] == 2 => at least one physical element is fully inside support A[k] == 3 => all physical elements are fully inside support\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.ImmersedSplines.active_splines-Tuple{SuiteSplines.CartesianProducts.TensorProduct{3, <:SuiteSplines.UnivariateSplines.SplineSpace}, Array{Int8, 3}}","page":"Index","title":"SuiteSplines.ImmersedSplines.active_splines","text":"active_splines(U::TensorProduct{Dim, <:SplineSpace}, E::Array)\n\nDetermine the active B-splines and boundary B-splines given a  distance function ϕ.\n\nA[k] == 0 => no physical elements in support of the function A[k] == 1 => boundary function with a physical cut element in its support A[k] == 2 => at least one physical element is fully inside support A[k] == 3 => all physical elements are fully inside support\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.ImmersedSplines.active_splines-Tuple{SuiteSplines.UnivariateSplines.SplineSpace, Vector{Int8}}","page":"Index","title":"SuiteSplines.ImmersedSplines.active_splines","text":"active_splines(U::TensorProduct{2, <:SplineSpace}, E::Array)\n\nDetermine the active B-splines and boundary B-splines given a  distance function ϕ.\n\nA[k] == 0 => no physical elements in support of the function A[k] == 1 => boundary function with a physical cut element in its support A[k] == 2 => at least one physical element is fully inside support A[k] == 3 => all physical elements are fully inside support\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.ImmersedSplines.compute_extension_coefficients-Tuple{Integer, Any, Int64, Int64}","page":"Index","title":"SuiteSplines.ImmersedSplines.compute_extension_coefficients","text":"compute_extension_coefficients(p, kts, span, k)\n\nCompute the extension coefficients using dual functionals. This works for general non-uniform knot vectors and is based on the paper [Höllig, Klaus,  and Ulrich Reif. \"Nonuniform web-splines.\" Computer Aided Geometric Design  20, no. 5 (2003): 277-294.]\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.ImmersedSplines.element_is_inside-Tuple{Any, Any}","page":"Index","title":"SuiteSplines.ImmersedSplines.element_is_inside","text":"elementisinside(Y::Matrix{Bool})\n\nReturn a boolean array that specifies whether an element is inside or  outside, respectively\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.ImmersedSplines.find_extension_indices-Tuple{Any, Any, Any}","page":"Index","title":"SuiteSplines.ImmersedSplines.find_extension_indices","text":"find_extension_indices(active_functions, gperm, mi)\n\nFind the extension indices that are closest to the boundary function with CartesianIndex mi.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.ImmersedSplines.find_first_active_element-Tuple{Any, Any, Any}","page":"Index","title":"SuiteSplines.ImmersedSplines.find_first_active_element","text":"find_extension_indices(active_functions, gperm, mi)\n\nFind the extension indices that are closest to the boundary function with CartesianIndex mi.\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.ImmersedSplines.point_is_inside-Tuple{Any, Any}","page":"Index","title":"SuiteSplines.ImmersedSplines.point_is_inside","text":"pointisinside(phi, partition::CartesianProduct)\n\nReturn a boolean array that specifies whether a point is inside or  outside, respectively\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.ImmersedSplines.spline_extension_operator-Union{Tuple{Dim}, Tuple{SuiteSplines.CartesianProducts.TensorProduct{Dim, <:SuiteSplines.UnivariateSplines.SplineSpace}, Any}} where Dim","page":"Index","title":"SuiteSplines.ImmersedSplines.spline_extension_operator","text":"spline_extension_operator(U::TensorProduct{2, <:SplineSpace}, F)\n\nCompute an extension operator that stabilizes the splinespace according to the definition of [Höllig, Klaus, Ulrich Reif, and Joachim Wipper. \"Weighted extended  B-spline approximation of Dirichlet problems.\" SIAM Journal on Numerical Analysis 39,  no. 2 (2001): 442-462.]\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.ImmersedSplines.ClosestExtensionArray","page":"Index","title":"SuiteSplines.ImmersedSplines.ClosestExtensionArray","text":"ClosestExtensionArray(F, U::TensorProduct{Dim,<:SplineSpace})\n\nDefines a closest index array, according to the definition of  [Höllig, Klaus, Ulrich Reif, and Joachim Wipper. \"Weighted extended B-spline approximation of Dirichlet problems.\" SIAM Journal on Numerical Analysis 39,  no. 2 (2001): 442-462.]\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.ImmersedSplines.ClosestExtensionArray-Union{Tuple{CartesianIndex{Dim}}, Tuple{Dim}} where Dim","page":"Index","title":"SuiteSplines.ImmersedSplines.ClosestExtensionArray","text":"ClosestExtensionArray(F, U::TensorProduct{Dim,<:SplineSpace})\n\nComputes a closest index array, according to the definition of  [Höllig, Klaus, Ulrich Reif, and Joachim Wipper. \"Weighted extended B-spline approximation of Dirichlet problems.\" SIAM Journal on Numerical Analysis 39,  no. 2 (2001): 442-462.]\n\n\n\n\n\n","category":"method"},{"location":"api/#SuiteSplines.ImmersedSplines.GeneratePerimeter","page":"Index","title":"SuiteSplines.ImmersedSplines.GeneratePerimeter","text":"GeneratePerimeter{Dim,Indices}\n\nDatastructure that allows iteration over active neighborhoods of boundary  functions\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.ImmersedSplines.IPerm","page":"Index","title":"SuiteSplines.ImmersedSplines.IPerm","text":"IPerm{Dim,Indices}\n\nIterator that returns active neighborhoods around a B-spline.\n\n\n\n\n\n","category":"type"},{"location":"api/#SuiteSplines.ImmersedSplines.ImmersedQuadRule","page":"Index","title":"SuiteSplines.ImmersedSplines.ImmersedQuadRule","text":"ImmersedQuadRule(map::AlgoimMapping, xa::Real, ya::Real, xb::Real, yb::Real, qo::Int64)\n\nCompute a algoim quadrature rule in bounding box [xa, ya] × [xb, yb] based on a Gauss-Legendre rule of qo points.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"warning: Experimental interface\nThis package implements interfaces that may eventually be integrated into the IgaBase.jl package.","category":"page"},{"location":"tutorials/SpecialSpaces/#SpecialSpaces.jl","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"","category":"section"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"The core function spaces in SuiteSplines are SplineSpace and tensor-products thereof.","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"SpecialSpaces.jl introduces convenient interfaces for handling spaces used to represent scalar-, vector- and mixed-valued fields and geometric mappings.","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"details: Note on higher dimensions\nAlmost everything described on this page generalizes to higher dimensions, e.g.Ω = Interval(0.0, 2.0) ⨱ Interval(0.0, 4.0) ⨱ Interval(-1.0, 1.0)\nΔ = Partition(Ω, (3, 5, 7));\nS = ScalarSplineSpace(4, Δ)The only exception are the Raviart-Thomas and Taylor-Hood spaces, which are implemented only in two and three dimensions.","category":"page"},{"location":"tutorials/SpecialSpaces/#Domains-and-partitions","page":"SpecialSpaces.jl","title":"Domains and partitions","text":"","category":"section"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"All spline spaces are defined on a Partition of some Domain. A Cartesian product domain in two dimensions may be defined as a Cartesian product of intervals,","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"Ω = Interval(0.0, 2.0) ⨱ Interval(0.0, 4.0)","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"A partition of the domain Ω is just another Cartesian product of a strictly increasing real numbers on the intervals defining each domain dimension. To generate an uniform partition we can use IncreasingRange,","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"Δ = IncreasingRange(Ω.data[1]..., 3) ⨱ IncreasingRange(Ω.data[2], 5)","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"Less explicitly, we can also call","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"Δ = Partition(Ω, (3, 5))","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"which gives us a Cartesian product partition with 3 breakpoints in the first and 5 breakpoints the second dimension.","category":"page"},{"location":"tutorials/SpecialSpaces/#Scalar-spline-spaces","page":"SpecialSpaces.jl","title":"Scalar spline spaces","text":"","category":"section"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"Given a partition, a tensor-product ScalarSplineSpace of degree 2 can be constructed by calling","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"S = ScalarSplineSpace(2, Δ)","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"This is equivalent to","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"SplineSpace(2, Δ.data[1]) ⨷ SplineSpace(2, Δ.data[2])","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"In fact, ScalarSplineSpace is just a type alias for a tensor-product of univariate spline spaces. The dimension of the tensor-product was inferred from the dimension of the provided partition. SpecialSpaces.jl implements a few more handy constructors for tensor-product spline spaces, e.g. with different degrees in each dimension.","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"Conveniently, we can obtain the dimension and linear indices of the tensor-product space by","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"linds = indices(S)\ndim = dimension(S)","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"Linear indices are useful when handling solution vectors, fields and geometric mappings on more complex spaces. These spaces follow next.","category":"page"},{"location":"tutorials/SpecialSpaces/#Vector-spline-spaces","page":"SpecialSpaces.jl","title":"Vector spline spaces","text":"","category":"section"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"A tensor-product VectorSplineSpace can be constructed from multiple scalar spline spaces,","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"V = VectorSplineSpace(S, S, S)","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"The requirement here is that the scalar spaces are defined on the same partition.","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"To access the scalar space corresponding to the kth component of a vector space, we can index into the collection,","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"V[1]\nV[1] == V[2] == V[3]","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"Note that in this example the domain dimension is two and the codomain dimension is three. More commonly, the dimension and codimension coincide and a vector space of degree 2 can be defined directly as","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"V = VectorSplineSpace(2, Δ)","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"The linear indices for each component are","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"for k in 1:2\n    @show indices(V, k)\nend","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"Note here the subtlety of calling indices(V, k) instead of indices(V[k]). The element type of V is","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"eltype(V)","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"Thus an expression like the one below will call the indices method for a scalar spline space,","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"indices.(V)","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"This does not give the desired result. The following expression on the other hand does,","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"indices.(Ref(V), 1:2)","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"As expected, the complete range of linear indices for a vector space is","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"indices(V)","category":"page"},{"location":"tutorials/SpecialSpaces/#Mixed-spline-spaces","page":"SpecialSpaces.jl","title":"Mixed spline spaces","text":"","category":"section"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"Mixed spline function spaces are defined as custom structs subtyping MixedSplineSpace, where each struct field corresponds to a scalar or vector spline space.","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"A basic definition of a custom mixed spline space might look like the following:","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"struct TaylorHood{Dim,T} <: MixedSplineSpace{Dim,T}\n    V::VectorSplineSpace{Dim,Dim,T}\n    Q::ScalarSplineSpace{Dim,T}\n    \n    function TaylorHood(p::Degree, Δ::Partition{Dim,T}) where {Dim,T<:Real}\n        @assert p ≥ 2\n        p = ntuple(i -> p, Dim)\n        V = VectorSplineSpace(ntuple(i -> ScalarSplineSpace(p, Δ), Dim)...)\n        Q = ScalarSplineSpace(p .- 1, Δ)\n        new{Dim,T}(V, Q)\n    end\nend","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"SpecialSpaces.jl implements interfaces that allow us to operate on such spaces.","category":"page"},{"location":"tutorials/SpecialSpaces/#Taylor–Hood","page":"SpecialSpaces.jl","title":"Taylor–Hood","text":"","category":"section"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"One implemented example of a mixed spline space is the TaylorHood space, which defines an inf-sub stable pair of spaces for velocities and pressure.","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"th = TaylorHood(2, Δ)\ndimension(th)\ndimension(th, :Q)\ndimension(th, :V)\ndimension(th, :V, 1)\ndimension(th, :V, 2)\nindices(th, :Q)\nindices(th, :V)\nindices(th, :V, 1)\nindices(th, :V, 2)","category":"page"},{"location":"tutorials/SpecialSpaces/#Raviart–Thomas","page":"SpecialSpaces.jl","title":"Raviart–Thomas","text":"","category":"section"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"Another implemented example of a mixed spline space is the RaviartThomas space, which constructs a structure preserving (divergence conforming) pair of spline spaces for velocities and pressure.","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"rt = RaviartThomas(2, Δ)\ndimension(rt)\ndimension(rt, :Q)\ndimension(rt, :V)\ndimension(rt, :V, 1)\ndimension(rt, :V, 2)\nindices(rt, :Q)\nindices(rt, :V)\nindices(rt, :V, 1)\nindices(rt, :V, 2)","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"Both examples are implemented for dimensions two and three and arbitrary degrees.","category":"page"},{"location":"tutorials/SpecialSpaces/#Iterable-mixed-spline-space","page":"SpecialSpaces.jl","title":"Iterable mixed spline space","text":"","category":"section"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"If a custom struct defining a mixed spline space is not desired, SpecialSpaces.jl implements an iterable mixed spline space for general use. IterableMixedSplineSpace can be constructed from a named tuple of scalar and vector spline spaces.","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"V = VectorSplineSpace(2, Δ)\nQ = ScalarSplineSpace(1, Δ)\nith = IterableMixedSplineSpace((V=V, Q=Q))\ndimension(ith, :Q)\ndimension(ith, :V)","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"The example above reproduces the Taylor–Hood mixed spline space.","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"In addition to the usual interface for mixed spaces, it is also possible to iterate over the spaces collected in the iterable mixed spline space,","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"map(dimension, ith)","category":"page"},{"location":"tutorials/SpecialSpaces/#Mappings","page":"SpecialSpaces.jl","title":"Mappings","text":"","category":"section"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"SpecialSpaces.jl implements convenient constructors for fields and geometric mappings defined on special spaces introduced above. For example,","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"ϕʰ = GeometricMapping(Ω, S);\nt = Field(V);\nuʰ = GeometricMapping(Ω, rt, :V);\npʰ = GeometricMapping(Ω, rt, :Q);","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"Now, given a solution vector x from some computation with the Raviart–Thomas space, we can set the coefficients of the geometric mappings uʰ and pʰ as follows","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"x = rand(dimension(rt));\nsetcoeffs!(uʰ, rt, :V, x);\nsetcoeffs!(pʰ, rt, :Q, x);","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"We can also obtain vertically concatenated coefficients of fields and geometric mappings,","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"getcoeffs(uʰ) == x[indices(rt, :V)]\ngetcoeffs(pʰ) == x[indices(rt, :Q)] ","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"The interface for scalar and vector spaces is identical but without the field symbol.","category":"page"},{"location":"tutorials/SpecialSpaces/#Constraints","page":"SpecialSpaces.jl","title":"Constraints","text":"","category":"section"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"Recall that space constraints on univariate SplineSpace are enforced by extraction operators,","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"space = SplineSpace(4, IncreasingRange(0.0, π, 5); cleft=[1,2])\nspace.C # extraction operator","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"Naturally, space constraints on tensor-product spaces can be enforced by Kronecker product extraction operators. To avoid tedious work on the level of univariate spline spaces, i.e. defining univariate spline spaces with the arguments cleft, cright, cperiodic, SpecialSpaces.jl implements containers for collecting constraints on scalar, vector and mixed spline spaces. Upon passing these collections to respective space constructors, the contraints are distributed down to the univariate spaces.","category":"page"},{"location":"tutorials/SpecialSpaces/#Scalar-spline-space-constraints","page":"SpecialSpaces.jl","title":"Scalar spline space constraints","text":"","category":"section"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"On the lowest abstraction level, there are three rather self-explanatory methods:","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"left_constraint!\nright_constraint!\nperiodic_constraint!","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"These methods operate on scalar constraint containers and push constraint conditions for a univariate spline space in dimension dim to the container.","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"The following is equivalent to setting cleft=[1] argument on the spline space in the first dimension of the tensor-product space.","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"C = ScalarSplineSpaceConstraints{2}()\nleft_constraint!(C; dim=1) # or left_constraint!(S; c=[1,], dim=1)","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"This constraint container with dimension two can be then applied while constructing a tensor-product space of dimension two. Let us reuse the existing scalar spline space S and construct a scalar spline space with constraint conditions defined in C","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"S\nS[1].C\nS = ScalarSplineSpace(S, C)\nS[1].C","category":"page"},{"location":"tutorials/SpecialSpaces/#Vector-spline-space-constraints","page":"SpecialSpaces.jl","title":"Vector spline space constraints","text":"","category":"section"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"Existing spaces can be used to construct suitable (empty) constraint containers. For example, to construct a constraints container for the vector spline space V we can write","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"C = VectorSplineSpaceConstraints(V)","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"VectorSplineSpaceConstraints is just a collection of ScalarSplineSpaceConstraints so that left_constraint!, right_constraint! and periodic_constraint! can be applied to each element of this container.","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"left_constraint!(C[1]; dim=1)\nV[1]\nV = VectorSplineSpace(V, C);\nV[1]","category":"page"},{"location":"tutorials/SpecialSpaces/#Mixed-spline-space-constraints","page":"SpecialSpaces.jl","title":"Mixed spline space constraints","text":"","category":"section"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"MixedSplineSpaceConstraints is just a type alias for a named tuple.","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"C = MixedSplineSpaceConstraints((V=VectorSplineSpaceConstraints(rt.V), Q=ScalarSplineSpaceConstraints(rt.Q)))\nC.V\nC.Q","category":"page"},{"location":"tutorials/SpecialSpaces/#Clamped-constraints","page":"SpecialSpaces.jl","title":"Clamped constraints","text":"","category":"section"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"For convenience, SuiteSplines.jl provides clamped_constraint! for scalar and vector spline spaces which can be set on edges/faces of the domain. For example,","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"C = VectorSplineSpaceConstraints(V)\nclamped_constraint!(C, :top)","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"This is equivalent to setting left_constraint! with the arguments (c=[1], dim=2) in each dimension of the vector space. It is also possible to clamp multiple edges in a subset of dimensions,","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"C = VectorSplineSpaceConstraints{3}()\nclamped_constraint!(C, :left, :right, :bottom, :top, :back, :front; dim=[1,3])","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"In this case, the scalar spline spaces in dimensions 1 and 3 are clamped on the whole boundary of the domain. No constraints are applied in dimension 2.","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"Clamping for scalar spline spaces works the same way. Valid boundary labels are: :left, :right, :bottom, :top, :back, :front, where the last two are only valid in three dimensions.","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"tip: Numbering and labeling boundaries on Cartesian grids\nSuiteSplines follows a simple convention for numbering boundaries of Cartesian product domains: boundaries are numbered dimension by dimension by assigning ever increasing integers first to the beginning then to the end of the interval in a particular dimension. The labels :left → :right, :bottom → :top, :back → :front are directed always in the direction of the axes. See boundary_number for more details.","category":"page"},{"location":"tutorials/SpecialSpaces/#Extraction-operators","page":"SpecialSpaces.jl","title":"Extraction operators","text":"","category":"section"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"To obtain the Kronecker product extraction operator of a scalar spline space use","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"extraction_operator(S)\nextraction_operator(S; sparse=true)","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"The parameter sparse can be used if we wish to obtain the Kronecker product extraction operator as a sparse matrix. ","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"To obtain the Kronecker product extraction operator of a vector spline space use","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"extraction_operator.(V)\nextraction_operator.(V; sparse=true)","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"or","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"extraction_operators(V)\nextraction_operators(V; sparse=true)","category":"page"},{"location":"tutorials/SpecialSpaces/","page":"SpecialSpaces.jl","title":"SpecialSpaces.jl","text":"Note, that the extraction operator is not stored in the constraints containers!","category":"page"},{"location":"tutorials/SpecialSpaces/#API","page":"SpecialSpaces.jl","title":"API","text":"","category":"section"},{"location":"tutorials/SpecialSpaces/#Base.eltype-Union{Tuple{Type{S}}, Tuple{S}, Tuple{T}, Tuple{Dim}} where {Dim, T<:Integer, S<:(SuiteSplines.SpecialSpaces.VectorSplineSpaceConstraints{Dim, <:Any, T})}","page":"SpecialSpaces.jl","title":"Base.eltype","text":"Base.eltype(::Type{S}) where {Dim,T<:Integer,S<:VectorSplineSpaceConstraints{Dim,<:Any,T}}\n\nReturn element type of VectorSplineSpaceConstraints collection.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#Base.eltype-Union{Tuple{Type{S}}, Tuple{S}, Tuple{T}} where {T<:Integer, S<:(SuiteSplines.SpecialSpaces.ScalarSplineSpaceConstraints{<:Any, T})}","page":"SpecialSpaces.jl","title":"Base.eltype","text":"Base.eltype(::Type{S}) where {T<:Integer,S<:ScalarSplineSpaceConstraints{<:Any,T}}\n\nReturn element type of ScalarSplineSpaceConstraints collection.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#Base.getindex-Union{Tuple{S}, Tuple{S, Int64}} where S<:SuiteSplines.SpecialSpaces.VectorFunctionSpace","page":"SpecialSpaces.jl","title":"Base.getindex","text":"Base.getindex(V::S, i::Int64) where {S<:VectorFunctionSpace}\n\nReturn ith vector function space component.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#Base.getindex-Union{Tuple{T}, Tuple{SuiteSplines.SpecialSpaces.ScalarSplineSpaceConstraints, T}} where T<:Integer","page":"SpecialSpaces.jl","title":"Base.getindex","text":"Base.getindex(C::ScalarSplineSpaceConstraints, i::T) where {T<:Integer}\n\nReturn ith component constraints in a ScalarSplineSpaceConstraints\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#Base.getindex-Union{Tuple{T}, Tuple{SuiteSplines.SpecialSpaces.VectorSplineSpaceConstraints, T}} where T<:Integer","page":"SpecialSpaces.jl","title":"Base.getindex","text":"Base.getindex(C::ScalarSplineSpaceConstraints, i::T) where {T<:Integer}\n\nReturn ith component constraints in a VectorSplineSpaceConstraints\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#Base.iterate-Tuple{SuiteSplines.SpecialSpaces.ScalarSplineSpaceConstraints}","page":"SpecialSpaces.jl","title":"Base.iterate","text":"Base.iterate(C::ScalarSplineSpaceConstraints)\nBase.iterate(C::ScalarSplineSpaceConstraints, i::T) where {T<:Integer} = iterate(C.data, i)\n\nIterate of the collection of UnivariateSplineSpaceConstraints stored in ScalarSplineSpaceConstraints.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#Base.iterate-Tuple{SuiteSplines.SpecialSpaces.VectorSplineSpaceConstraints}","page":"SpecialSpaces.jl","title":"Base.iterate","text":"Base.iterate(C::VectorSplineSpaceConstraints)\nBase.iterate(C::VectorSplineSpaceConstraints, i::T) where {T<:Integer} = iterate(C.data, i)\n\nIterate of the collection of ScalarSplineSpaceConstraints stored in VectorSplineSpaceConstraints.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#Base.iterate-Tuple{S} where S<:SuiteSplines.SpecialSpaces.VectorFunctionSpace","page":"SpecialSpaces.jl","title":"Base.iterate","text":"Base.iterate(V::S) where {S<:VectorFunctionSpace} = iterate(parent(V))\nBase.iterate(V::S, i::Int) where {S<:VectorFunctionSpace} = iterate(parent(V), i)\n\nIterate over vector function space components.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#Base.length-Tuple{S} where S<:SuiteSplines.SpecialSpaces.VectorFunctionSpace","page":"SpecialSpaces.jl","title":"Base.length","text":"Base.length(V::S) where {S<:VectorFunctionSpace}\n\nReturn the number of vector function space components.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#Base.length-Union{Tuple{SuiteSplines.SpecialSpaces.ScalarSplineSpaceConstraints{Dim}}, Tuple{Dim}} where Dim","page":"SpecialSpaces.jl","title":"Base.length","text":"Base.length(C::ScalarSplineSpaceConstraints{Dim}) where {Dim}\n\nReturn number of dimensions Dim.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#Base.length-Union{Tuple{SuiteSplines.SpecialSpaces.VectorSplineSpaceConstraints{<:Any, Codim}}, Tuple{Codim}} where Codim","page":"SpecialSpaces.jl","title":"Base.length","text":"Base.length(C::VectorSplineSpaceConstraints{<:Any,Codim}) where {Codim}\n\nReturn number of dimensions Dim.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.IgaBase.dimension-Tuple{SuiteSplines.CartesianProducts.TensorProduct{Dim, SuiteSplines.UnivariateSplines.SplineSpace{T}} where {Dim, T}}","page":"SpecialSpaces.jl","title":"SuiteSplines.IgaBase.dimension","text":"dimensions(V::ScalarSplineSpace)\n\nReturn the dimension of a ScalarSplineSpace.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.IgaBase.dimension-Tuple{T} where T<:SuiteSplines.SpecialSpaces.MixedFunctionSpace","page":"SpecialSpaces.jl","title":"SuiteSplines.IgaBase.dimension","text":"IgaBase.dimension(V::T) where {T<:MixedFunctionSpace}\n\nReturn the dimension of a mixed function space.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.IgaBase.dimension-Tuple{T} where T<:SuiteSplines.SpecialSpaces.VectorFunctionSpace","page":"SpecialSpaces.jl","title":"SuiteSplines.IgaBase.dimension","text":"IgaBase.dimension(V::T) where {T<:VectorFunctionSpace}\n\nReturn the dimension of a vector function space.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.IgaBase.dimension-Union{Tuple{T}, Tuple{T, Int64}} where T<:SuiteSplines.SpecialSpaces.VectorFunctionSpace","page":"SpecialSpaces.jl","title":"SuiteSplines.IgaBase.dimension","text":"IgaBase.dimension(V::T, k::Int) where {T<:VectorFunctionSpace}\n\nReturn the dimension of the ith component of a vector function space.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.IgaBase.dimension-Union{Tuple{T}, Tuple{T, Symbol, Int64}} where T<:SuiteSplines.SpecialSpaces.MixedFunctionSpace","page":"SpecialSpaces.jl","title":"SuiteSplines.IgaBase.dimension","text":"IgaBase.dimension(V::T, field::Symbol, i::Int64) where {T<:MixedFunctionSpace}\n\nReturn the dimension of the ith component of a vector function space field in a mixed space V.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.IgaBase.dimension-Union{Tuple{T}, Tuple{T, Symbol}} where T<:SuiteSplines.SpecialSpaces.MixedFunctionSpace","page":"SpecialSpaces.jl","title":"SuiteSplines.IgaBase.dimension","text":"IgaBase.dimension(V::T, field::Symbol) where {T<:MixedFunctionSpace}\n\nReturn the dimension of a scalar function space field in a mixed space V.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.IgaBase.numbertype-Union{Tuple{SuiteSplines.SpecialSpaces.FunctionSpace{<:Any, <:Any, T}}, Tuple{T}} where T","page":"SpecialSpaces.jl","title":"SuiteSplines.IgaBase.numbertype","text":"IgaBase.numbertype(::FunctionSpace{<:Any,<:Any,T}) where {T}\n\nReturn the data type used by a function space to represent numbers.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.IgaBase.numbertype-Union{Tuple{SuiteSplines.SpecialSpaces.MixedFunctionSpace{<:Any, <:Any, T}}, Tuple{T}} where T","page":"SpecialSpaces.jl","title":"SuiteSplines.IgaBase.numbertype","text":"IgaBase.numbertype(::MixedFunctionSpace{<:Any,T}) where {T}\n\nReturn the data type for numbers used in space.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.boundary_number-Tuple{Symbol}","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.boundary_number","text":"boundary_number(s::Symbol)\n\nReturn the boundary number corresponding to boundary s.\n\n                                               5\n                            4                 back\n                           top                  . . . . . . .\n                     . . . . . . . .            . .         . .\nη                    .             .            .   .       .   .\n.                    .             .            .     . . . . . . .\n.             left   .             .  right     .     .     .     .\n.               1    .             .    2       .     .     .     .\n· · · ·  ξ           .             .            . . . . . . .     .\n  ·                  . . . . . . . .              .   .       .   .\n    ·                    bottom                     . .         . .\n      ζ                     3                         . . . . . . .\n                                                                 front\n                                                                   6\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.boundary_symbol-Tuple{Int64}","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.boundary_symbol","text":"boundary_symbol(s::Int)\n\nReturn the boundary label (symbol) for boundary number s.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.clamped_constraint!-Union{Tuple{N}, Tuple{Dim}, Tuple{SuiteSplines.SpecialSpaces.ScalarSplineSpaceConstraints{Dim}, Vararg{Symbol, N}}} where {Dim, N}","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.clamped_constraint!","text":"clamped_constraint!(C::ScalarSplineSpaceConstraints, side::Vararg{Symbol,N}) where {N}\n\nClamp a scalar spline space at side, where side is one of the boundary labels:\n\n:left\n:right\n:bottom\n:top\n:back\n:front\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.clamped_constraint!-Union{Tuple{N}, Tuple{Dim}, Tuple{SuiteSplines.SpecialSpaces.VectorSplineSpaceConstraints{Dim}, Vararg{Symbol, N}}} where {Dim, N}","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.clamped_constraint!","text":"clamped_constraint!(C::VectorSplineSpaceConstraints{Dim}, side::Vararg{Symbol,N}; dim=1:Dim) where {Dim,N}\n\nClamp a vector spline space in dimensions dim at side, where side is one of the boundary labels:\n\n:left\n:right\n:bottom\n:top\n:back\n:front\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.codimfunspace-Union{Tuple{SuiteSplines.SpecialSpaces.FunctionSpace{<:Any, Codim}}, Tuple{Codim}} where Codim","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.codimfunspace","text":"codimfunspace(::FunctionSpace{<:Any,Codim})\n\nReturn codomain dimension of function space\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.dimensions-Tuple{SuiteSplines.CartesianProducts.TensorProduct{Dim, SuiteSplines.UnivariateSplines.SplineSpace{T}} where {Dim, T}}","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.dimensions","text":"dimensions(V::ScalarSplineSpace)\n\nReturn the dimension of a ScalarSplineSpace in each tensor-product direction as a tuple.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.dimensions-Tuple{T} where T<:SuiteSplines.SpecialSpaces.MixedFunctionSpace","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.dimensions","text":"dimensions(V::T) where {T<:MixedFunctionSpace}\n\nReturn the dimension in each tensor-product direction of a mixed function space as a tuple.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.dimensions-Tuple{T} where T<:SuiteSplines.SpecialSpaces.VectorFunctionSpace","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.dimensions","text":"dimensions(V::T) where {T<:VectorFunctionSpace}\n\nReturn the dimension in each tensor-product direction of a vector function space as a tuple.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.dimensions-Union{Tuple{T}, Tuple{T, Int64}} where T<:SuiteSplines.SpecialSpaces.VectorFunctionSpace","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.dimensions","text":"dimensions(V::T, i::Int64) where {T<:VectorFunctionSpace}\n\nReturn the dimension in each tensor-product direction of the ith component of a vector function space as a tuple.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.dimensions-Union{Tuple{T}, Tuple{T, Symbol, Int64}} where T<:SuiteSplines.SpecialSpaces.MixedFunctionSpace","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.dimensions","text":"dimensions(V::T, field::Symbol, i::Int64) where {T<:MixedFunctionSpace}\n\nReturn the dimension in each tensor-product direction of the ith component of a vector function space field in the mixed space V as a tuple.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.dimensions-Union{Tuple{T}, Tuple{T, Symbol}} where T<:SuiteSplines.SpecialSpaces.MixedFunctionSpace","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.dimensions","text":"dimensions(V::T, field::Symbol, i::Int64) where {T<:MixedFunctionSpace}\n\nReturn the dimension in each tensor-product direction of the vector function space field in the mixed space V as a tuple.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.dimfunspace-Union{Tuple{SuiteSplines.SpecialSpaces.FunctionSpace{Dim}}, Tuple{Dim}} where Dim","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.dimfunspace","text":"dimfunspace(::FunctionSpace{Dim}) where {Dim}\n\nReturn domain dimension of function space.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.extraction_operator-Tuple{SuiteSplines.CartesianProducts.TensorProduct{Dim, SuiteSplines.UnivariateSplines.SplineSpace{T}} where {Dim, T}}","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.extraction_operator","text":"extraction_operator(S::ScalarSplineSpace; sparse::Bool=false)\n\nReturn the extraction operator for a scalar function space.\n\nIf sparse is true, return a sparse matrix.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.extraction_operator-Union{Tuple{T}, Tuple{T, Symbol}} where T<:SuiteSplines.SpecialSpaces.MixedFunctionSpace","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.extraction_operator","text":"extraction_operator(S::T, field::Symbol; sparse::Bool=false) where {T<:MixedFunctionSpace}\n\nReturn the extraction operator for a scalar function space field in  mixed function space S.\n\nIf sparse is true, return a sparse matrix.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.extraction_operators-Tuple{T} where T<:SuiteSplines.SpecialSpaces.VectorFunctionSpace","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.extraction_operators","text":"extraction_operators(S::T; sparse::Bool=false) where {T<:VectorFunctionSpace}\n\nReturn the extraction operator for a vector function space.\n\nIf sparse is true, return a tuple of sparse matrices.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.extraction_operators-Union{Tuple{T}, Tuple{T, Symbol}} where T<:SuiteSplines.SpecialSpaces.MixedFunctionSpace","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.extraction_operators","text":"extraction_operators(S::T, field::Symbol; sparse::Bool=false) where {T<:MixedFunctionSpace}\n\nReturn the extraction operators for a vector function space field in  mixed function space S in a tuple.\n\nIf sparse is true, return a tuple of sparse matrices.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.getcoeffs-Tuple{SuiteSplines.AbstractMappings.Field{<:Any, 1}}","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.getcoeffs","text":"getcoeffs(f::Field)\ngetcoeffs(f::GeometricMapping)\n\nReturn a vector of vertically concatenated (tensor-product Bspline) mapping coefficients.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.indices-Tuple{SuiteSplines.CartesianProducts.TensorProduct{Dim, SuiteSplines.UnivariateSplines.SplineSpace{T}} where {Dim, T}}","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.indices","text":"indices(V::ScalarSplineSpace)\n\nReturn linear indices for a scalar function space.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.indices-Tuple{S} where S<:SuiteSplines.SpecialSpaces.MixedFunctionSpace","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.indices","text":"indices(space::S) where {S<:MixedFunctionSpace}\n\nReturn linear indices for a mixed function space.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.indices-Tuple{S} where S<:SuiteSplines.SpecialSpaces.VectorFunctionSpace","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.indices","text":"indices(space::S) where {S<:VectorFunctionSpace}\n\nReturn linear indices for a vector function space.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.indices-Union{Tuple{S}, Tuple{S, Int64}} where S<:SuiteSplines.SpecialSpaces.VectorFunctionSpace","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.indices","text":"indices(space::S, i::Int) where {S<:VectorFunctionSpace}\n\nReturn linear indices for ith component of a vector function space.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.indices-Union{Tuple{S}, Tuple{S, Symbol, Int64}} where S<:SuiteSplines.SpecialSpaces.MixedFunctionSpace","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.indices","text":"indices(space::S, field::Symbol, i::Int) where {S<:MixedFunctionSpace}\n\nReturn linear indices for ith component of a vector function space field in mixed function space space.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.indices-Union{Tuple{S}, Tuple{S, Symbol}} where S<:SuiteSplines.SpecialSpaces.MixedFunctionSpace","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.indices","text":"indices(space::S, field::Symbol) where {S<:MixedFunctionSpace}\n\nReturn linear indices for a function space field in mixed function space space.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.left_constraint!-Union{Tuple{SuiteSplines.SpecialSpaces.ScalarSplineSpaceConstraints{Dim}}, Tuple{Dim}} where Dim","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.left_constraint!","text":"left_constraint!(C::ScalarSplineSpaceConstraints{Dim}; c::Vector{Int}=Int[1], dim::Int) where {Dim}\n\nPush c to vector in left field of UnivariateSplineSpaceConstraints stored at index dim in ScalarSplineSpaceConstraints.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.periodic_constraint!-Union{Tuple{SuiteSplines.SpecialSpaces.ScalarSplineSpaceConstraints{Dim}}, Tuple{Dim}} where Dim","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.periodic_constraint!","text":"periodic_constraint!(C::ScalarSplineSpaceConstraints{Dim}; c::Vector{Int}, dim::Int) where {Dim}\n\nPush c to vector in periodic field of UnivariateSplineSpaceConstraints stored at index dim in ScalarSplineSpaceConstraints.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.right_constraint!-Union{Tuple{SuiteSplines.SpecialSpaces.ScalarSplineSpaceConstraints{Dim}}, Tuple{Dim}} where Dim","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.right_constraint!","text":"right_constraint!(C::ScalarSplineSpaceConstraints{Dim}; c::Vector{Int}=Int[1], dim::Int) where {Dim}\n\nPush c to vector in right field of UnivariateSplineSpaceConstraints stored at index dim in ScalarSplineSpaceConstraints.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.setcoeffs!-Union{Tuple{T}, Tuple{M}, Tuple{M, Vector{T}}, Tuple{M, Vector{T}, Int64}, Tuple{M, Vector{T}, Int64, UnitRange{Int64}}} where {M<:SuiteSplines.IgaBase.AbstractMapping, T<:Real}","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.setcoeffs!","text":"setcoeffs!(f::M, v::Vector{T}, k::Int=1, slice::Base.UnitRange{Int}=Base.UnitRange(1,length(v))) where {M<:AbstractMapping,T<:Real}\n\nSet coefficients of a mapping component to a slice of coefficients in a vector.\n\nArguments:\n\nf: mapping in question\nv: vector with coeffs\nslice: range of indices of vector v\nk: component of field f \n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.setcoeffs!-Union{Tuple{T}, Tuple{S}, Tuple{M}, Tuple{M, S, Symbol, Vector{T}}} where {M<:SuiteSplines.IgaBase.AbstractMapping, S<:SuiteSplines.SpecialSpaces.MixedSplineSpace, T<:Real}","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.setcoeffs!","text":"setcoeffs!(f::M, mixedspace::S, field::Symbol, v::Vector{T}) where {M<:AbstractMapping,S<:MixedSplineSpace,T<:Real}\n\nSet coefficients of a mapping defined on a mixedspace.\n\nArguments:\n\nf: mapping in question\nmixedspace: space\nfield: space field\nv: vector with coeffs with length dim(mixedspace)\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.setcoeffs!-Union{Tuple{T}, Tuple{S}, Tuple{M}, Tuple{M, S, Vector{T}}} where {M<:SuiteSplines.IgaBase.AbstractMapping, S<:(SuiteSplines.CartesianProducts.TensorProduct{Dim, SuiteSplines.UnivariateSplines.SplineSpace{T}} where {Dim, T}), T<:Real}","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.setcoeffs!","text":"setcoeffs!(f::M, scalarspace::S, v::Vector{T}) where {M<:AbstractMapping,S<:ScalarSplineSpace,T<:Real}\n\nSet coefficients of a mapping defined on a scalar space.\n\nArguments:\n\nf: mapping in question\nscalarspace: space\nv: vector with coeffs with length dim(scalarspace)\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.setcoeffs!-Union{Tuple{T}, Tuple{S}, Tuple{M}, Tuple{M, S, Vector{T}}} where {M<:SuiteSplines.IgaBase.AbstractMapping, S<:SuiteSplines.SpecialSpaces.VectorSplineSpace, T<:Real}","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.setcoeffs!","text":"setcoeffs!(f::M, vectorspace::S, v::Vector{T}) where {M<:AbstractMapping,S<:VectorSplineSpace,T<:Real}\n\nSet coefficients of a mapping defined on a vector space.\n\nArguments:\n\nf: mapping in question\nvectorspace: space\nv: vector with coeffs with length dim(vectorspace)\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.AbstractMappings.Field-Tuple{S} where S<:(SuiteSplines.CartesianProducts.TensorProduct{Dim, SuiteSplines.UnivariateSplines.SplineSpace{T}} where {Dim, T})","page":"SpecialSpaces.jl","title":"SuiteSplines.AbstractMappings.Field","text":"Field(space::S) where {S<:ScalarSplineSpace}\nField(space::S) where {S<:VectorSplineSpace}\nField(space::S, s::Symbol) where {S<:MixedSplineSpace}\n\nConstruct field on some spline spaces.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.AbstractMappings.GeometricMapping-Tuple{Any, SuiteSplines.SpecialSpaces.VectorSplineSpace}","page":"SpecialSpaces.jl","title":"SuiteSplines.AbstractMappings.GeometricMapping","text":"AbstractMappings.GeometricMapping(domain, args::ScalarScalarSpace; orientation::Int=1)\nAbstractMappings.GeometricMapping(domain, args::VectorSplineSpace; orientation::Int=1)\nAbstractMappings.GeometricMapping(domain, args::MixedSplineSpace, field::Symbol; orientation::Int=1)\n\nConstruct geometric mapping on some spline spaces.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.Domain","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.Domain","text":"const Domain{Dim,T} = CartesianProduct{Dim,Tuple{Vararg{T,Dim}},Tuple{Vararg{Interval{T},Dim}}}\n\nAlias for CartesianProduct of Interval defining a domain.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.FunctionSpace","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.FunctionSpace","text":"abstract type FunctionSpace{Dim,Codim,T}\n\nConcrete function spaces subtype this.\n\nParameters\n\nDim: dimension of the domain\nCodim: dimension of the codomain\nT: data type used for numbers (returned by IgaBase.numbertype)\n\n\n\n\n\n","category":"type"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.IterableMixedSplineSpace","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.IterableMixedSplineSpace","text":"struct IterableMixedSplineSpace{Dim,Codim,T} <: MixedSplineSpace{Dim,Codim,T}\n\nA general purpose mixed spline space, which can be constructed from a named tuple consisting of scalar and vector spline spaces. Besides the usual interface to mixed function spaces, it additionally supports iteration over the collection of spaces.\n\nThe supplied spaces must have the same domain dimension, partition and number type.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.MixedFunctionSpace","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.MixedFunctionSpace","text":"abstract type MixedFunctionSpace{Dim,T}\n\nMixed spaces like MixedSplineSpace subtype this.\n\nMixed function spaces are expected to collect components as struct fields.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.MixedSplineSpace","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.MixedSplineSpace","text":"abstract type MixedSplineSpace{Dim,Codim,T} <: MixedFunctionSpace{Dim,Codim,T}\n\nConcrete mixed spaces like RaviartThomas subtype this.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.MixedSplineSpaceConstraints","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.MixedSplineSpaceConstraints","text":"const MixedSplineSpaceConstraints\n\nType alias for NamedTuple which serves as a container for mixed space constraints.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.MixedSplineSpaceConstraints-Tuple{SuiteSplines.SpecialSpaces.TaylorHood}","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.MixedSplineSpaceConstraints","text":"MixedSplineSpaceConstraints(S::RaviartThomas{Dim}) where {Dim}\n\nConstruct a constraints container for TaylorHood.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.MixedSplineSpaceConstraints-Union{Tuple{SuiteSplines.SpecialSpaces.RaviartThomas{Dim}}, Tuple{Dim}} where Dim","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.MixedSplineSpaceConstraints","text":"MixedSplineSpaceConstraints(S::RaviartThomas{Dim}) where {Dim}\n\nConstruct a constraints container for RaviartThomas.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.Partition","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.Partition","text":"const Partition{Dim,T} = CartesianProduct{Dim,Tuple{Vararg{T,Dim}},Tuple{Vararg{IncreasingRange{T},Dim}}}\n\nAlias for CartesianProduct defining a partition.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.Partition-Tuple{SuiteSplines.CartesianProducts.TensorProduct{Dim, SuiteSplines.UnivariateSplines.SplineSpace{T}} where {Dim, T}}","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.Partition","text":"Partition(S::ScalarSplineSpace)\n\nReturn the partition corresponding to a ScalarSplineSpace.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.Partition-Tuple{SuiteSplines.SpecialSpaces.MixedSplineSpace}","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.Partition","text":"Partition(space::MixedSplineSpace)\n\nReturn the partition corresponding to a MixedSplineSpace.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.Partition-Tuple{SuiteSplines.SpecialSpaces.VectorSplineSpace}","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.Partition","text":"Partition(S::VectorSplineSpace)\n\nReturn the partition corresponding to a VectorSplineSpace.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.Partition-Union{Tuple{S}, Tuple{T}, Tuple{Dim}, Tuple{S, NTuple{Dim, Int64}}} where {Dim, T<:Real, S<:SuiteSplines.CartesianProducts.CartesianProduct{Dim, NTuple{Dim, T}, NTuple{Dim, SuiteSplines.SortedSequences.Interval{T}}}}","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.Partition","text":"Partition(domain::S, n::NTuple{Dim, Int64}) where {Dim,T<:Real,S<:Domain{Dim,T}}\n\nReturn an uniform Partition of Domain with nₖ breakpoints in kth dimension.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.RaviartThomas","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.RaviartThomas","text":"struct RaviartThomas{Dim,Codim,T} <: MixedSplineSpace{Dim,Codim,T}\n\nStructure preserving pair of spline spaces for velocities and pressure in two and three dimensions.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.RaviartThomas-Union{Tuple{T}, Tuple{Dim}, Tuple{Integer, SuiteSplines.CartesianProducts.CartesianProduct{Dim, NTuple{Dim, T}, NTuple{Dim, S}} where S<:SuiteSplines.SortedSequences.IncreasingSequence{T}}} where {Dim, T<:Real}","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.RaviartThomas","text":"RaviartThomas(p::Degree, Δ::Partition{Dim,T}) where {Dim,T<:Real}\nRaviartThomas(p::Degree, Δ::Partition{2,T}, C::MixedSplineSpaceConstraints{(:V,:Q)})\nRaviartThomas(p::Degree, Δ::Partition{3,T}, C::MixedSplineSpaceConstraints{(:V,:Q)}) where {T<:Real}\n\nConstruct a RaviartThomas mixed spline space.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.ScalarSplineSpace","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.ScalarSplineSpace","text":"Type alias for a tensor-product SplineSpace.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.ScalarSplineSpace-Union{Tuple{T}, Tuple{Dim}, Tuple{NTuple{Dim, Integer}, SuiteSplines.CartesianProducts.CartesianProduct{Dim, NTuple{Dim, T}, NTuple{Dim, S}} where S<:SuiteSplines.SortedSequences.IncreasingSequence{T}, SuiteSplines.SpecialSpaces.ScalarSplineSpaceConstraints{Dim}}} where {Dim, T<:Real}","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.ScalarSplineSpace","text":"ScalarSplineSpace(S::ScalarSplineSpace{Dim,T}) where {Dim,T<:Real}\nScalarSplineSpace(p::Degree, partition::Partition{Dim,T}) where {Dim,T<:Real}\nScalarSplineSpace(degrees::NTuple{Dim,Degree}, partition::Partition{Dim,T}) where {Dim,T<:Real}\nScalarSplineSpace(degrees::NTuple{Dim,Degree}, partition::Partition{Dim,T}, C::ScalarSplineSpaceConstraints{Dim}) where {Dim,T<:Real}\nScalarSplineSpace(S::ScalarSplineSpace{Dim,T}, C::ScalarSplineSpaceConstraints{Dim}) where {Dim,T<:Real}\n\nConstruct a ScalarSplineSpace.\n\nIf constructed from another ScalarSplineSpace, discard constraint conditions.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.ScalarSplineSpaceConstraints","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.ScalarSplineSpaceConstraints","text":"struct ScalarSplineSpaceConstraints{Dim,T}\n\nContainer for ScalarSplineSpace constraints.\n\nField data stores a tuple of UnivariateSplineSpaceConstraints for each tensor-product dimension of ScalarSplineSpace.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.ScalarSplineSpaceConstraints-Union{Tuple{F}, Tuple{Dim}} where {Dim, F<:(SuiteSplines.CartesianProducts.TensorProduct{Dim, SuiteSplines.UnivariateSplines.SplineSpace{T}} where T)}","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.ScalarSplineSpaceConstraints","text":"ScalarSplineSpaceConstraints(::F) where {Dim,F<:ScalarSplineSpace{Dim}}\n\nConstruct a constraints container for a ScalarSplineSpace.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.ScalarSplineSpaceConstraints-Union{Tuple{}, Tuple{Dim}} where Dim","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.ScalarSplineSpaceConstraints","text":"ScalarSplineSpaceConstraints{Dim}() where {Dim}\nScalarSplineSpaceConstraints{Dim,T}() where {Dim,T<:Integer}\n\nConstruct default ScalarSplineSpaceConstraints for a ScalarSplineSpace of dimension Dim.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.SplineSpaceConstraints","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.SplineSpaceConstraints","text":"abstract type SplineSpaceConstraints{T}\n\nConcrete spline space constraints container subtype this.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.TaylorHood","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.TaylorHood","text":"struct TaylorHood{Dim,T} <: MixedSplineSpace{Dim,T}\n\nAn inf-sup stable pair of spline spaces for velocities and pressure in two and three dimensions.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.TaylorHood-Union{Tuple{T}, Tuple{Dim}, Tuple{Integer, SuiteSplines.CartesianProducts.CartesianProduct{Dim, NTuple{Dim, T}, NTuple{Dim, S}} where S<:SuiteSplines.SortedSequences.IncreasingSequence{T}, NamedTuple{(:V, :Q)}}} where {Dim, T<:Real}","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.TaylorHood","text":"TaylorHood(p::Degree, Δ::Partition{Dim,T}) where {Dim,T<:Real}\nTaylorHood(p::Degree, Δ::Partition{Dim,T}, C::MixedSplineSpaceConstraints{(:V,:Q)}) where {Dim,T<:Real}\n\nConstruct a TaylorHood mixed spline space.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.UnivariateSplineSpaceConstraints","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.UnivariateSplineSpaceConstraints","text":"struct UnivariateSplineSpaceConstraints{T}\n\nContainer for SplineSpace constraints, i.e. cleft, cright, cperiodic vectors in SplineSpace constructor stored as left, rightand periodic field.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.UnivariateSplineSpaceConstraints-Tuple{}","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.UnivariateSplineSpaceConstraints","text":"UnivariateSplineSpaceConstraints()\n\nConstruct default UnivariateSplineSpaceConstraints\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.VectorFunctionSpace","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.VectorFunctionSpace","text":"abstract type VectorFunctionSpace{Dim,T}\n\nConcrete vector spaces like VectorSplineSpace subtype this.\n\nVector function spaces are expected to collect components as a tuple in field :V.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.VectorSplineSpace-Union{Tuple{T}, Tuple{Codim}, Tuple{Dim}, Tuple{SuiteSplines.SpecialSpaces.VectorSplineSpace{Dim, Codim, T}, SuiteSplines.SpecialSpaces.VectorSplineSpaceConstraints{Dim, Codim}}} where {Dim, Codim, T<:Real}","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.VectorSplineSpace","text":"VectorSplineSpace(degree::Degree, partition::Partition{Dim,T}) where {Dim,T<:Real}\nVectorSplineSpace(degrees::NTuple{Dim,Degree}, partition::Partition{Dim,T}) where {Dim,T<:Real}\nVectorSplineSpace(V::VectorSplineSpace{Dim,Codim,T}, C::VectorSplineSpaceConstraints{Dim,Codim}) where {Dim,Codim,T<:Real}\nVectorSplineSpace(S::ScalarSplineSpace{Dim,T}) where {Dim,T<:Real}\nVectorSplineSpace(V::NTuple{Codim,ScalarSplineSpace{Dim,T}}) where {Dim,Codim,T}\nVectorSplineSpace(V::Vararg{ScalarSplineSpace{Dim,T},Codim}) where {Dim,Codim,T}\n\nConstruct a VectorSplineSpace.\n\nConstraints on scalar spline space arguments are preserved.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.VectorSplineSpaceConstraints","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.VectorSplineSpaceConstraints","text":"struct ScalarSplineSpaceConstraints{Dim,T}\n\nContainer for ScalarSplineSpaceConstraints.\n\nField data stores a tuple of ScalarSplineSpaceConstraints for each component of VectorSplineSpace.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.VectorSplineSpaceConstraints-Union{Tuple{F}, Tuple{Codim}, Tuple{Dim}} where {Dim, Codim, F<:(SuiteSplines.SpecialSpaces.VectorSplineSpace{Dim, Codim})}","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.VectorSplineSpaceConstraints","text":"VectorSplineSpaceConstraints(::F) where {Dim,Codim,F<:VectorSplineSpace{Dim,Codim}}\n\nConstruct a constraints container for a VectorSplineSpace.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/SpecialSpaces/#SuiteSplines.SpecialSpaces.VectorSplineSpaceConstraints-Union{Tuple{}, Tuple{Dim}} where Dim","page":"SpecialSpaces.jl","title":"SuiteSplines.SpecialSpaces.VectorSplineSpaceConstraints","text":"VectorSplineSpaceConstraints{Dim}() where {Dim}\nVectorSplineSpaceConstraints{Dim,Codim}() where {Dim,Codim}\nVectorSplineSpaceConstraints(args::Vararg{ScalarSplineSpaceConstraints{Dim},Codim}) where {Dim,Codim}\nVectorSplineSpaceConstraints{T}(args::Vararg{ScalarSplineSpaceConstraints{Dim},Codim}) where {Dim,Codim,T}\nVectorSplineSpaceConstraints{Dim,Codim,T}() where {Dim,Codim,T<:Integer}\n\nConstruct VectorSplineSpaceConstraints for a VectorSplineSpace of dimension Dim and codomain dimension Codim.\n\n\n\n\n\n","category":"method"},{"location":"#SuiteSplines","page":"About","title":"SuiteSplines","text":"","category":"section"},{"location":"","page":"About","title":"About","text":"SuiteSplines is a collection of Julia packages designed for applications in isogeometric analysis.","category":"page"},{"location":"","page":"About","title":"About","text":"The SuiteSplines.jl package is intended for registration in the General repository and bundles stable and compatible versions of core packages in the SuiteSplines framework:","category":"page"},{"location":"","page":"About","title":"About","text":"IgaBase.jl\nSortedSequences.jl\nCartesianProducts.jl\nKroneckerProducts.jl\nAbstractMappings.jl\nUnivariateSplines.jl\nTensorProductBsplines.jl\nNURBS.jl\nIgaFormation.jl\nImmersedSplines.jl\nBezierBernsteinMethods.jl\nSpecialSpaces.jl","category":"page"},{"location":"","page":"About","title":"About","text":"The documentation of SuiteSplines.jl includes tutorials and example usage for each of the core packages. ","category":"page"},{"location":"#Reexporting-submodules","page":"About","title":"Reexporting submodules","text":"","category":"section"},{"location":"","page":"About","title":"About","text":"SuiteSplines.jl groups core packages into submodules, such as SuiteSplines.UnivariateSplines. By default, to avoid polluting the namespace, SuiteSplines.jl does not expose any functionality directly. The submodules are only accessible through SuiteSplines.UnivariateSplines, SuiteSplines.SortedSequences, etc.","category":"page"},{"location":"","page":"About","title":"About","text":"To conveniently access functionality from specific submodules, you can use the @suitesplines_reexport macro.","category":"page"},{"location":"","page":"About","title":"About","text":"For example, to reexport UnivariateSplines and SortedSequences, you can write:","category":"page"},{"location":"","page":"About","title":"About","text":"julia> using SuiteSplines\n\njulia> @suitesplines_reexport SortedSequences UnivariateSplines\n\njulia> I = Interval(0.0, 2.0);\n\njulia> S = SplineSpace(2, I, 5)\nSplineSpace(degree = 2, interval = [0.0, 2.0], dimension = 7)","category":"page"},{"location":"","page":"About","title":"About","text":"If called without arguments, @suitesplines_reexport will reexport all submodules (see SUITESPLINES_PKGS).","category":"page"},{"location":"","page":"About","title":"About","text":"julia> @suitesplines_reexport\n\njulia> BezierSimplex <: BezierBernsteinMethods.AbstractSimplex\ntrue","category":"page"},{"location":"","page":"About","title":"About","text":"As indicated by the previous prompt, only the names originally exported by a submodule are reexported when calling @suitesplines_reexport.","category":"page"},{"location":"#Local-registry","page":"About","title":"Local registry","text":"","category":"section"},{"location":"","page":"About","title":"About","text":"The latest versions of core packages are registered in SuiteSplinesRegistry.","category":"page"},{"location":"","page":"About","title":"About","text":"tip: Using core packages independently\nTo use the core SuiteSplines packages independently, you can add SuiteSplines registry to your depot(@v1.10) pkg> registry add https://github.com/SuiteSplines/SuiteSplinesRegistry.gitThis will make all packages in our local registry available in the package manager just like the packages in the General Julia registry. To add TensorProductBsplines.jl to the active environment you can call(@v1.10) pkg> add TensorProductBsplinesAlternatively, if you already have SuiteSplines.jl added to your environment and prefer not to look up the URL of the local registry, you can simply calljulia> using SuiteSplines; SuiteSplines.add_registry()","category":"page"},{"location":"#Contributing","page":"About","title":"Contributing","text":"","category":"section"},{"location":"","page":"About","title":"About","text":"If you wish to contribute to SuiteSplines, please do so directly in one of the core packages. All SuiteSplines packages are listed here. For more specialized, comprehensive contributions consider contributing a new package like TruncatedHierarchicalBsplines.jl.","category":"page"}]
}
